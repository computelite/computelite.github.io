{
    "Sample_DB": "\nBEGIN TRANSACTION;\n\nCREATE TABLE T_QueryLogs (\n\tLogTime      VARCHAR DEFAULT (datetime('now', 'localtime') ),\n\tQuerySQL     VARCHAR,\n\tQueryMsg     VARCHAR\n);\n\nCREATE TABLE T_TaskLogs (\n        ID              INTEGER PRIMARY KEY AUTOINCREMENT,\n        TaskId          VARCHAR,\n        TaskName        VARCHAR NOT NULL,\n        ProcessId       VARCHAR,\n        TaskStatus      VARCHAR,\n        StartDate       VARCHAR DEFAULT (datetime('now', 'localtime') ),\n        EndDate         VARCHAR,\n        ErrorMsg        VARCHAR,\n        Alerted         INTEGER DEFAULT (0),\n        TaskDbId        VARCHAR,\n        MasterTaskId    VARCHAR\n);\n\nCREATE TABLE T_SolverLog (\n    LogTime    VARCHAR DEFAULT (datetime('now', 'localtime') ),\n    LogMessage VARCHAR\n);\n\nCREATE TABLE S_ModelParams (\n    ParamName    VARCHAR,\n    ParamValue   VARCHAR\n);\n\nINSERT INTO S_ModelParams VALUES('ModelIcon','fas fa-cube');\nINSERT INTO S_ModelParams VALUES('ModelName','Sample DB');\nINSERT INTO S_ModelParams VALUES('DBVersion','1.0.0');\n\nCREATE TABLE S_TableParameters (\n    TableName      VARCHAR,\n    ColumnName     VARCHAR,\n    ParameterType  VARCHAR,\n    ParameterValue VARCHAR,\n    UNIQUE(TableName,ColumnName,ParameterType)\n);\n\nCREATE TABLE S_TableGroup (\n    GroupName        VARCHAR,\n    TableName        VARCHAR,\n    TableDisplayName VARCHAR,\n    TableType        VARCHAR,\n    ColumnOrder      VARCHAR,\n    Table_Status     VARCHAR,\n    Freeze_Col_Num   NUMERIC\n);\n\nINSERT INTO S_TableGroup (GroupName, TableName, TableDisplayName, TableType, ColumnOrder, Table_Status, Freeze_Col_Num) VALUES ('Log Tables', 'T_TaskLogs', 'Task Logs', 'Task Logs', NULL, 'Active', NULL);\nINSERT INTO S_TableGroup (GroupName, TableName, TableDisplayName, TableType, ColumnOrder, Table_Status, Freeze_Col_Num) VALUES ('Log Tables', 'T_SolverLog', 'Solver Logs', 'Solver Logs', NULL, 'Active', NULL);\nINSERT INTO S_TableGroup (GroupName, TableName, TableDisplayName, TableType, ColumnOrder, Table_Status, Freeze_Col_Num) VALUES ('Setups', 'S_TableGroup', 'Table Group', 'Input', NULL, 'Active', NULL);\nINSERT INTO S_TableGroup (GroupName, TableName, TableDisplayName, TableType, ColumnOrder, Table_Status, Freeze_Col_Num) VALUES ('Setups', 'S_TableParameters', 'Table Parameters', 'Input', NULL, 'Active', NULL);\nINSERT INTO S_TableGroup (GroupName, TableName, TableDisplayName, TableType, ColumnOrder, Table_Status, Freeze_Col_Num) VALUES ('Setups', 'S_TaskMaster', 'Task Master', 'Input', NULL, 'Active', NULL);\nINSERT INTO S_TableGroup (GroupName, TableName, TableDisplayName, TableType, ColumnOrder, Table_Status, Freeze_Col_Num) VALUES ('Setups', 'S_ExecutionFiles', 'Code Files', 'Input', NULL, 'Active', NULL);\nINSERT INTO S_TableGroup (GroupName, TableName, TableDisplayName, TableType, ColumnOrder, Table_Status, Freeze_Col_Num) VALUES ('All Other', 'V_TEMPV', 'Temp View', 'Output', NULL, 'Active', NULL);\nINSERT INTO S_TableGroup (GroupName, TableName, TableDisplayName, TableType, ColumnOrder, Table_Status, Freeze_Col_Num) VALUES('All Other','S_DataFiles','Data Files','Input','[\"FileId\",\"FileName\",\"FileType\",\"Status\"]','Active',NULL);\nINSERT INTO S_TableGroup (GroupName, TableName, TableDisplayName, TableType, ColumnOrder, Table_Status, Freeze_Col_Num) VALUES('All Other','S_PackageWheels','PackageWheels','Input','[\"WheelId\",\"WheelName\",\"Status\"]','Active',NULL);\nINSERT INTO S_TableGroup (GroupName, TableName, TableDisplayName, TableType, ColumnOrder, Table_Status, Freeze_Col_Num) VALUES('All Other','S_Notebooks','Notebooks','Input',null,'Active',NULL);\nINSERT INTO S_TableGroup (GroupName, TableName, TableDisplayName, TableType, ColumnOrder, Table_Status, Freeze_Col_Num) VALUES('All Other','S_NotebookContent','Notebook Contents','Input',null,'Active',NULL);\n\nCREATE TABLE S_TaskMaster (\n\tTaskId\t            INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n\tTaskName\t        VARCHAR,\n\tTaskDisplayName\t    VARCHAR,\n\tTaskType\t        VARCHAR DEFAULT 'PythonScript',\n\tTaskParameters\t    VARCHAR,\n\tTaskStatus\t        VARCHAR,\n\tTaskLastRunDate\t    VARCHAR,\n\tTaskOutput\t        VARCHAR\n);\n\nINSERT INTO S_TaskMaster(TaskId, TaskName, TaskDisplayName,TaskType) VALUES(1,'cats.py','Download Cats','PythonScript');\nINSERT INTO S_TaskMaster(TaskId, TaskName, TaskDisplayName,TaskType) VALUES(2,'dogs.py','Show Dog','PythonScript');\n\nCREATE TABLE S_ExecutionFiles (\n\tFileId\t            INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n\tFileName\t        VARCHAR,\n\tFileLabel   \t    VARCHAR,\n    FilePath            VARCHAR UNIQUE,\n    FileData            VARCHAR,\n\tStatus\t            VARCHAR DEFAULT ('Active')\t\n);\n\nINSERT INTO S_ExecutionFiles VALUES(1,'main.py',NULL,'main.py',replace('from foo.bar import main as bar\nfrom foo.foo import main as foo\n\nprint(\"Hello from main.py\")\nbar()\nfoo()','\n',char(10)),'Active');\nINSERT INTO S_ExecutionFiles VALUES(2,'bar.py',NULL,'foo/bar.py',replace('def main():\n    print(\"Hello from bar.py\")','\n',char(10)),'Active');\nINSERT INTO S_ExecutionFiles VALUES(3,'foo.py',NULL,'foo/foo.py',replace('def main():\n    print(\"Hello from foo.py\")','\n',char(10)),'Active');\nINSERT INTO S_ExecutionFiles VALUES(4,'requirements.txt',NULL,'requirements.txt',replace('urllib3\nPillow\npandas\nsqlite3\npulp\nhighspy','\n',char(10)),'Active');\nINSERT INTO S_ExecutionFiles VALUES(5,'dogs.py',NULL,'dogs.py',replace('# Sample code to display random dog images \nimport urllib3, json, os,io\nfrom pyodide.ffi import to_js\n\nurl = \"https://random.dog/woof.json\"\nresponse  = urllib3.request(\"GET\", url)\nimg_url = response.json()[''url'']\n\nextension = \"\"\n\nwhile extension not in (\"JPEG\", \"PNG\", \"JPG\", \"GIF\"):\n    response  = urllib3.request(\"GET\", url)\n    img_url = response.json()[''url'']\n    print(img_url)\n    extension = img_url.split(\".\")[-1].upper()\n\nresponse = urllib3.request(\"GET\", img_url)\n\nbuf = io.BytesIO(response.data)\n\nto_js(buf.getvalue())','\n',char(10)),'Active');\nINSERT INTO S_ExecutionFiles VALUES(6,'cats.py',NULL,'cats.py',replace('# Sample code to download random cat images \nimport urllib3, os,io, shutil\nfrom pyodide.ffi import to_js\nfrom PIL import Image\n\n# This is the Output Dir, which is accessible from HomePage\noutput_dir = r''outputDir/''\n\nexpected_size_collage = (900, 900)\nexpected_size_image = (300, 300)\n\ncollage = Image.new(\"RGBA\", expected_size_collage, color=(255,255,255,255))\nurl = \"https://cataas.com/cat?type=square\"\n\nfor h in range(0, expected_size_collage[1], expected_size_image[1]):\n    for w in range(0, expected_size_collage[0], expected_size_image[0]):\n        image_data  = urllib3.request(\"GET\", url).data\n        image = Image.open(io.BytesIO(image_data)).convert(\"RGBA\")\n\n        # Get the original image width and height\n        image_width = image.size[0]\n        image_height = image.size[1]\n\n        # Get how the width and height should be\n        width_factor = image_width / expected_size_image[0]\n        height_factor = image_height / expected_size_image[1]\n\n        image = image.resize(expected_size_image)\n\n        # Copy image to collage canvas\n        collage.paste(image, (w, h))\n\nout_collage = io.BytesIO()\ncollage.save(out_collage, \"PNG\")\n\n# Saving to outputDir, so it could be visible from HomePage \"Files --> OutputFiles\"\ncollage.save(''outputDir/cats.png'')\nout_collage.seek(0)\nto_js(out_collage.getvalue())','\n',char(10)),'Active');\nINSERT INTO S_ExecutionFiles VALUES(7,'list_input_files.py',NULL,'list_input_files.py',replace('import os\nprint(os.listdir(\"inputDir\"))','\n',char(10)),'Active');\nINSERT INTO S_ExecutionFiles VALUES(8,'pandaas.py',NULL,'pandaas.py',replace('import sqlite3\nimport pandas as pd\n\n# thisDB is a keyword for current SQLite database\nconn = sqlite3.connect(thisDB)\n\ndf = pd.read_sql_query(\"SELECT * from sqlite_master\", conn)\n\nall_tables = list(df[''tbl_name''][df.type == ''table''])\n\nfor table_name in all_tables:\n    query = f\"select count(*) from [{table_name}]\" \n    res = conn.execute(query).fetchall()\n    count = res[0][0]\n    if count > 0:\n        output_str = f\"Table {table_name} has {count} records\"\n        print(output_str)\n','\n',char(10)),'Active');\nINSERT INTO S_ExecutionFiles VALUES(9,'write_output_file.py',NULL,'write_output_file.py',replace('import os\\012\\012# This is the Output Dir, which is accessible from HomePage\\012output_dir = r''outputDir''\\012\\012input_file_name = f''{output_dir}/output_file.txt''\\012with open(input_file_name, ''w'') as fl:\\012    for i in range(100):\\012  \t    fl.write(f''Hello from ComputeLite! count({i+1})'')\\012    fl.close()\\012  \\012z = os.listdir(output_dir)\\012print(z)','\\012',char(10)),'Active');\nINSERT INTO S_ExecutionFiles VALUES(10,'update_sqlite_db.py',NULL,'update_sqlite_db.py',replace('import sqlite3\n\nquery = \"INSERT INTO T_SolverLog (LogMessage) Values (''Hello from ComputeLite'')\"\n\nwith sqlite3.connect(thisDB) as conn:\n    conn.execute(query)\n  \n# Check solver log table: Log Tables > Solver Logs\n','\n',char(10)),'Active');\nINSERT INTO S_ExecutionFiles VALUES(11,'blending_problem_with_pulp_highs.py',NULL,'blending_problem_with_pulp_highs.py',replace('# Import PuLP modeler functions\nfrom pulp import * \n\n# Create the ''prob'' variable to contain the problem data\nprob = LpProblem(\"The Whiskas Problem\", LpMinimize)\n# The 2 variables Beef and Chicken are created with a lower limit of zero\nx1 = LpVariable(\"ChickenPercent\", 0, None, LpInteger)\nx2 = LpVariable(\"BeefPercent\", 0)\n\n# The objective function is added to ''prob'' first\nprob += 0.013 * x1 + 0.008 * x2, \"Total Cost of Ingredients per can\"\n\n# The five constraints are entered\nprob += x1 + x2 == 100, \"PercentagesSum\"\nprob += 0.100 * x1 + 0.200 * x2 >= 8.0, \"ProteinRequirement\"\nprob += 0.080 * x1 + 0.100 * x2 >= 6.0, \"FatRequirement\"\nprob += 0.001 * x1 + 0.005 * x2 <= 2.0, \"FibreRequirement\"\nprob += 0.002 * x1 + 0.005 * x2 <= 0.4, \"SaltRequirement\"\n\nsolver = HiGHS() #Define HiGHS solver, include highspy in requirement.txt\nprob.writeLP(\"outputDir/WhiskasModel.lp\")\nprob.solve(solver) #Use HiGHS solver\nprint(\"Status:\", LpStatus[prob.status])\n\nfor v in prob.variables():\n    print(v.name, \"=\", v.varValue)\n\nprint(\"Total Cost of Ingredients per can = \", value(prob.objective))','\n',char(10)),'Active');\n\n\nCREATE TABLE S_DataFiles (\n\tFileId\t            INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n\tFileName\t        VARCHAR,\n\tFileType   \t        VARCHAR,\n    FileBlob            BLOB NOT NULL,\n\tStatus\t            VARCHAR DEFAULT ('Active'),\n    UNIQUE(FileName,FileType)\t\n);\n\nCREATE TABLE S_PackageWheels (\n\tWheelId\t            INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n\tWheelName\t        VARCHAR UNIQUE,\n    WheelBlob            BLOB NOT NULL,\n\tStatus\t            VARCHAR DEFAULT ('Active')\t\n);\n\nCREATE TABLE S_Notebooks (\n\tNotebookId\t    INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n\tName            VARCHAR,\n\tType\t\t\tVARCHAR,\n\tStatus\t    \tVARCHAR DEFAULT 'Active',\n\tCreationDate\tVARCHAR DEFAULT (datetime('now','localtime')),\n\tLastUpdateDate\tVARCHAR DEFAULT (datetime('now','localtime'))\n);\n\nINSERT INTO S_Notebooks (Name,Type,Status) VALUES ('Default','Javascript','Active');\nINSERT INTO S_Notebooks (Name,Type,Status) VALUES ('Default','Python','Active');\nINSERT INTO S_Notebooks (Name,Type,Status) VALUES ('Default','R','Active');\nINSERT INTO S_Notebooks (Name,Type,Status) VALUES ('D3_Examples','Javascript','Active');\n\nCREATE TABLE S_NotebookContent (\n    CellId\t        INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n\tName            VARCHAR,\n    NotebookId      INTEGER NOT NULL,    \n\tCellContent\t    VARCHAR,\n    CellType        VARCHAR,\n\tCreationDate\tVARCHAR DEFAULT (datetime('now','localtime')),\n\tLastUpdateDate\tVARCHAR DEFAULT (datetime('now','localtime'))\n);\n\nINSERT INTO S_NotebookContent (Name, NotebookId, CellType, CellContent) VALUES ('Default', 1, 'javascript',REPLACE(\n'// Load external libraries dynamically from a CDN using loadCDNScripts\nawait loadCDNScripts([{ url: \"https://cdn.jsdelivr.net/npm/lodash/lodash.min.js\", globalVar: \"_\" },\n    { url: \"https://cdn.jsdelivr.net/npm/dayjs/dayjs.min.js\", globalVar: \"dayjs\" },\n    { url: \"https://cdn.jsdelivr.net/npm/chart.js\", globalVar: \"Chart\" }\n]);\n\nconsole.log(_.chunk([1, 2, 3, 4], 2));\n\nconsole.log(dayjs().format());\n\nconst canvas = document.createElement(\"canvas\");\nconst ctx = canvas.getContext(\"2d\");\nnew Chart(ctx, {\n    type: \"bar\",\n    data: {\n        labels: [\"Red\", \"Blue\", \"Yellow\"],\n        datasets: [{ \n            label: \"Votes\",\n            data: [12, 19, 3],\n            backgroundColor: [\"red\", \"blue\", \"yellow\"] \n        }] \n    } \n});\ncanvas', '\n', CHAR(10)\n));\nINSERT INTO S_NotebookContent (Name, NotebookId, CellType, CellContent) VALUES ('Default',1, 'javascript', REPLACE(\n'// Fetch data from the database\n// The executeQuery function executes an SQL query and retrieves data from the database.\n// In this case, we are selecting all records from the ''S_tablegroup'' table.\n\nconst result = await executeQuery(\"select * from S_tablegroup\")\nconsole.log(\"result\", result);', '\n', CHAR(10)\n));\nINSERT INTO S_NotebookContent (Name, NotebookId, CellType, CellContent) VALUES ('Default',1, 'javascript',REPLACE(\n'// Load external CSS dynamically from a CDN using loadCDNStylesheets\n\nawait loadCDNStylesheets([\n    { url: \"https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css\" }\n]);', '\n', CHAR(10)\n));\n\nINSERT INTO S_NotebookContent (Name, NotebookId, CellType, CellContent) VALUES ('Default',2,'python',REPLACE(\n        'import matplotlib.pyplot as plt\n' ||\n        'import numpy as np\n',\n        '\n',\n        CHAR(10)\n    )\n);\n\nINSERT INTO S_NotebookContent (Name, NotebookId, CellType, CellContent) VALUES ('Default',2,'python',REPLACE(\n        'speciess = (\n' ||\n        '    \"Adelie\\n $\\\\mu=$3700.66g\",\n' ||\n        '    \"Chinstrap\\n $\\\\mu=$3733.09g\",\n' ||\n        '    \"Gentoo\\n $\\\\mu=5076.02g$\",\n' ||\n        ')\n' ||\n        'wght_counts = {\n' ||\n        '    \"Below\": np.array([70, 31, 58]),\n' ||\n        '    \"Above\": np.array([82, 37, 66]),\n' ||\n        '}\n' ||\n        'widths = 0.5\n' ||\n        '\n' ||\n        'fig, ax = plt.subplots()\n' ||\n        'bottom = np.zeros(3)\n' ||\n        '\n' ||\n        'for boolean, weight_count in wght_counts.items():\n' ||\n        '    ax.bar(speciess, weight_count, widths, label=boolean, bottom=bottom)\n' ||\n        '    bottom += weight_count\n' ||\n        '\n' ||\n        'ax.set_title(\"Number of penguins with above average body mass\")\n' ||\n        'ax.legend(loc=\"upper right\")\n' ||\n        '\n' ||\n        'plt.show()\n',\n        '\n',\n        CHAR(10)\n    )\n);\n\nINSERT INTO S_NotebookContent (Name, NotebookId, CellType, CellContent) VALUES ('Default',2,'python',REPLACE(\n        'np.random.seed(19680801)\n' ||\n        '\n' ||\n        'dt = 0.01\n' ||\n        't = np.arange(0, 30, dt)\n' ||\n        'nse1 = np.random.randn(len(t))  # white noise 1\n' ||\n        'nse2 = np.random.randn(len(t))  # white noise 2\n' ||\n        '\n' ||\n        '# Two signals with a coherent part at 10 Hz and a random part\n' ||\n        's1 = np.sin(2 * np.pi * 10 * t) + nse1\n' ||\n        's2 = np.sin(2 * np.pi * 10 * t) + nse2\n' ||\n        '\n' ||\n        'fig, axs = plt.subplots(2, 1, layout=\"constrained\")\n' ||\n        'axs[0].plot(t, s1, t, s2)\n' ||\n        'axs[0].set_xlim(0, 2)\n' ||\n        'axs[0].set_xlabel(\"Time (s)\")\n' ||\n        'axs[0].set_ylabel(\"s1 and s2\")\n' ||\n        'axs[0].grid(True)\n' ||\n        '\n' ||\n        'cxy, f = axs[1].cohere(s1, s2, NFFT=256, Fs=1. / dt)\n' ||\n        'axs[1].set_ylabel(\"Coherence\")\n' ||\n        '\n' ||\n        'plt.show()\n',\n        '\n',\n        CHAR(10)\n    )\n);\n\n\nINSERT INTO S_NotebookContent (Name, NotebookId, CellType, CellContent) VALUES ('Default',3,'r',REPLACE(\n        '# Plotting a simple graph\n' ||\n        'plot(1:10, (1:10)^2, type = \"b\",\n' ||\n        '     col = \"blue\",\n' ||\n        '     main = \"Simple Plot\",\n' ||\n        '     xlab = \"X-Axis\",\n' ||\n        '     ylab = \"Y-Axis\")\n',\n        '\n',\n        CHAR(10)\n    )\n);\n\nINSERT INTO S_NotebookContent (Name, NotebookId, CellType, CellContent) VALUES ('Default',3,'r',REPLACE(\n        'population_vector <- c(10, 20, 30, 40, 50)\n' ||\n        '\n' ||\n        'sampled_vector <- sample(population_vector, size = 3, replace = TRUE)\n' ||\n        'print(sampled_vector)\n',\n        '\n',\n        CHAR(10)\n    )\n);\n\nINSERT INTO S_NotebookContent (Name, NotebookId, CellType, CellContent) VALUES ('Default',3,'r',REPLACE(\n        '# Load the package\n' ||\n        'library(ggplot2)\n' ||\n        '\n' ||\n        '# Run a sample function from ggplot2 to verify installation\n' ||\n        'print(ggplot(mpg, aes(x = displ, y = hwy)) + geom_point())\n',\n        '\n',\n        CHAR(10)\n    )\n);\n\nINSERT INTO S_NotebookContent (Name, NotebookId, CellType, CellContent) \nVALUES ('D3_Examples', 4, 'javascript', REPLACE(\n'// Load external libraries dynamically from a CDN using loadCDNScripts\n' ||\n'await loadCDNScripts([\n' ||\n'    { url: \"https://cdn.jsdelivr.net/npm/lodash/lodash.min.js\", globalVar: \"_\" },\n' ||\n'    { url: \"https://cdn.jsdelivr.net/npm/dayjs/dayjs.min.js\", globalVar: \"dayjs\" },\n' ||\n'    { url: \"https://cdn.jsdelivr.net/npm/chart.js\", globalVar: \"Chart\" },\n' ||\n'    { url: \"https://cdn.jsdelivr.net/npm/d3@7\", globalVar: \"d3\" },\n' ||\n'    { url: \"https://cdn.jsdelivr.net/npm/topojson@3.0.2/dist/topojson.min.js\", globalVar: \"topojson\" }\n' ||\n']);',\n'\n', CHAR(10)\n));\n\nINSERT INTO S_NotebookContent (Name, NotebookId, CellType, CellContent) \nVALUES ('D3_Examples', 4, 'javascript', REPLACE(\n'height = 500\n' ||\n'width = 500\n' ||\n'radius = 6\n' ||\n'step = radius * 2\n' ||\n'theta = Math.PI * (3 - Math.sqrt(5))\n\n' ||\n\n'zoomingData = Array.from({length: 2000}, (_, i) => {\n' ||\n'  const r = step * Math.sqrt(i += 0.5), a = theta * i;\n' ||\n'  return [\n' ||\n'    width / 2 + r * Math.cos(a),\n' ||\n'    height / 2 + r * Math.sin(a)\n' ||\n'  ];\n' ||\n'})\n\n' ||\n\n'zoomingChart = (() => {\n' ||\n'  let currentTransform = [width / 2, height / 2, height];\n\n' ||\n\n'  const svg = d3.create(\"svg\")\n' ||\n'      .attr(\"viewBox\", [0, 0, width, height]);\n\n' ||\n\n'  const g = svg.append(\"g\");\n\n' ||\n\n'  g.selectAll(\"circle\")\n' ||\n'    .data(zoomingData)\n' ||\n'    .join(\"circle\")\n' ||\n'      .attr(\"cx\", ([x]) => x)\n' ||\n'      .attr(\"cy\", ([, y]) => y)\n' ||\n'      .attr(\"r\", radius)\n' ||\n'      .attr(\"fill\", (d, i) => d3.interpolateRainbow(i / 360));\n\n' ||\n\n'  function transition() {\n' ||\n'    const d = zoomingData[Math.floor(Math.random() * zoomingData.length)];\n' ||\n'    const i = d3.interpolateZoom(currentTransform, [...d, radius * 2 + 1]);\n\n' ||\n\n'    g.transition()\n' ||\n'        .delay(250)\n' ||\n'        .duration(i.duration)\n' ||\n'        .attrTween(\"transform\", () => t => transform(currentTransform = i(t)))\n' ||\n'        .on(\"end\", transition);\n' ||\n'  }\n\n' ||\n\n'  function transform([x, y, r]) {\n' ||\n'    return `\n' ||\n'      translate(${width / 2}, ${height / 2})\n' ||\n'      scale(${height / r})\n' ||\n'      translate(${-x}, ${-y})\n' ||\n'    `;\n' ||\n'  }\n\n' ||\n\n'  return svg.call(transition).node();\n' ||\n'})();\n\n' ||\n\n'thisDiv.appendChild(zoomingChart);',\n'\n', CHAR(10)\n));\n\nINSERT INTO S_NotebookContent (Name, NotebookId, CellType, CellContent) \nVALUES ('D3_Examples', 4, 'javascript', REPLACE(\n'const k = 10;\n' ||\n'const m = 200;\n' ||\n'const n = 20;\n\n' ||\n\n'// Define the bump function separately\n' ||\n'function bump(a, n) {\n' ||\n'  const x = 1 / (0.1 + Math.random());\n' ||\n'  const y = 2 * Math.random() - 0.5;\n' ||\n'  const z = 10 / (0.1 + Math.random());\n' ||\n'  for (let i = 0; i < n; ++i) {\n' ||\n'    const w = (i / n - y) * z;\n' ||\n'    a[i] += x * Math.exp(-w * w);\n' ||\n'  }\n' ||\n'}\n\n' ||\n\n'// Define the bumps function properly\n' ||\n'function bumps(n, m) {\n' ||\n'  const a = Array(n).fill(0); // Initialize array with zeros\n' ||\n'  for (let i = 0; i < m; ++i) bump(a, n);\n' ||\n'  return a;\n' ||\n'}\n\n' ||\n\n'// Define and render the stream graph\n' ||\n'async function streamChart() {\n' ||\n'  const width = 928;\n' ||\n'  const height = 500;\n\n' ||\n\n'  const x = d3.scaleLinear([0, m - 1], [0, width]);\n' ||\n'  const y = d3.scaleLinear([0, 1], [height, 0]);\n' ||\n'  const z = d3.interpolateCool;\n\n' ||\n\n'  const area = d3.area()\n' ||\n'    .x((d, i) => x(i))\n' ||\n'    .y0(d => y(d[0]))\n' ||\n'    .y1(d => y(d[1]));\n\n' ||\n\n'  const stack = d3.stack()\n' ||\n'    .keys(d3.range(n))\n' ||\n'    .offset(d3.stackOffsetWiggle)\n' || \n'    .order(d3.stackOrderNone);\n\n' ||\n\n'  function randomize() {\n' ||\n'    const layers = stack(d3.transpose(Array.from({ length: n }, () => bumps(m, k))));\n' ||\n'    y.domain([\n' ||\n'      d3.min(layers, l => d3.min(l, d => d[0])),\n' ||\n'      d3.max(layers, l => d3.max(l, d => d[1]))\n' ||\n'    ]);\n' ||\n'    return layers;\n' ||\n'  }\n\n' ||\n\n'  const svg = d3.create(\"svg\")\n' ||\n'    .attr(\"viewBox\", [0, 0, width, height])\n' ||\n'    .attr(\"width\", width)\n' ||\n'    .attr(\"height\", height)\n' ||\n'    .attr(\"style\", \"max-width: 100%; height: auto;\");\n\n' ||\n\n'  const path = svg.selectAll(\"path\")\n' ||\n'    .data(randomize())\n' ||\n'    .join(\"path\")\n' ||\n'    .attr(\"d\", area)\n' ||\n'    .attr(\"fill\", () => z(Math.random()));\n\n' ||\n\n'  // Ensure `outputArea` exists\n' ||\n'  thisDiv.appendChild(svg.node());\n\n' ||\n\n'  // Animation Loop\n' ||\n'  while (true) {\n' ||\n'    await new Promise(resolve => setTimeout(resolve, 1000));\n\n' ||\n\n'    await path\n' ||\n'      .data(randomize())\n' ||\n'      .transition()\n' ||\n'      .duration(1500)\n' ||\n'      .attr(\"d\", area)\n' ||\n'      .end();\n' ||\n'  }\n' ||\n'}\n\n' ||\n\n'// Run the chart\n' ||\n'streamChart();',\n'\n', CHAR(10)\n));\n\nINSERT INTO S_NotebookContent (Name, NotebookId, CellType, CellContent) \nVALUES ('D3_Examples', 4, 'javascript', REPLACE(\n'arcChart = (() => {\n' ||\n'  const width = 500;\n' ||\n'  const height = Math.min(500, width / 2);\n' ||\n'  const outerRadius = height / 2 - 10;\n' ||\n'  const innerRadius = outerRadius * 0.75;\n\n' ||\n\n'  const tau = 2 * Math.PI;\n\n' ||\n\n'  const svg = d3.create(\"svg\")\n' ||\n'    .attr(\"viewBox\", [0, 0, width, height]);\n\n' ||\n\n'  const g = svg.append(\"g\")\n' ||\n'    .attr(\"transform\", `translate(${width / 2},${height / 2})`);\n\n' ||\n\n'  const arc = d3.arc()\n' ||\n'    .innerRadius(innerRadius)\n' ||\n'    .outerRadius(outerRadius)\n' ||\n'    .startAngle(0);\n\n' ||\n\n'  // Background arc\n' ||\n'  g.append(\"path\")\n' ||\n'    .datum({ endAngle: tau })\n' ||\n'    .style(\"fill\", \"#ddd\")\n' ||\n'    .attr(\"d\", arc);\n\n' ||\n\n'  // Foreground arc\n' ||\n'  const foreground = g.append(\"path\")\n' ||\n'    .datum({ endAngle: 0.127 * tau })\n' ||\n'    .style(\"fill\", \"orange\")\n' ||\n'    .attr(\"d\", arc);\n\n' ||\n\n'  // Transition function\n' ||\n'  function arcTween(newAngle) {\n' ||\n'    return function(d) {\n' ||\n'      const interpolate = d3.interpolate(d.endAngle, newAngle);\n' ||\n'      return function(t) {\n' ||\n'        d.endAngle = interpolate(t);\n' ||\n'        return arc(d);\n' ||\n'      };\n' ||\n'    };\n' ||\n'  }\n\n' ||\n\n'  // Interval for animation\n' ||\n'  const interval = d3.interval(() => {\n' ||\n'    foreground.transition()\n' ||\n'      .duration(750)\n' ||\n'      .attrTween(\"d\", arcTween(Math.random() * tau));\n' ||\n'  }, 1500);\n\n' ||\n\n'  // Return the SVG node\n' ||\n'  return svg.node();\n' ||\n'})();\n\n' ||\n\n'thisDiv.appendChild(arcChart);',\n'\n', CHAR(10)\n));\n\nINSERT INTO S_NotebookContent (Name, NotebookId, CellType, CellContent) \nVALUES ('D3_Examples', 4, 'javascript', REPLACE(\n'chordData = Object.assign([\n' ||\n'  [.096899, .008859, .000554, .004430, .025471, .024363, .005537, .025471],\n' ||\n'  [.001107, .018272, .000000, .004983, .011074, .010520, .002215, .004983],\n' ||\n'  [.000554, .002769, .002215, .002215, .003876, .008306, .000554, .003322],\n' ||\n'  [.000554, .001107, .000554, .012182, .011628, .006645, .004983, .010520],\n' ||\n'  [.002215, .004430, .000000, .002769, .104097, .012182, .004983, .028239],\n' ||\n'  [.011628, .026024, .000000, .013843, .087486, .168328, .017165, .055925],\n' ||\n'  [.000554, .004983, .000000, .003322, .004430, .008859, .017719, .004430],\n' ||\n'  [.002215, .007198, .000000, .003322, .016611, .014950, .001107, .054264]\n' ||\n'], {\n' ||\n'  names: [\"Apple\", \"HTC\", \"Huawei\", \"LG\", \"Nokia\", \"Samsung\", \"Sony\", \"Other\"],\n' ||\n'  colors: [\"#c4c4c4\", \"#69b40f\", \"#ec1d25\", \"#c8125c\", \"#008fc8\", \"#10218b\", \"#134b24\", \"#737373\"]\n' ||\n'});\n\n' ||\n\n'function groupTicks(d, step) {\n' ||\n'  const k = (d.endAngle - d.startAngle) / d.value;\n' ||\n'  return d3.range(0, d.value, step).map(value => ({\n' ||\n'    value: value,\n' ||\n'    angle: value * k + d.startAngle\n' ||\n'  }));\n' ||\n'}\n\n' ||\n\n'chordChart = (() => {\n' ||\n'  const width = 928;\n' ||\n'  const height = width;\n' ||\n'  const { names, colors } = chordData;\n' ||\n'  const outerRadius = Math.min(width, height) * 0.5 - 60;\n' ||\n'  const innerRadius = outerRadius - 10;\n' ||\n'  const tickStep = d3.tickStep(0, d3.sum(chordData.flat()), 100);\n' ||\n'  const formatValue = d3.format(\".1%\");\n\n' ||\n\n'  const chord = d3.chord()\n' ||\n'      .padAngle(0.02)\n' ||\n'      .sortSubgroups(d3.descending)\n' ||\n'      .sortChords(d3.descending);\n\n' ||\n\n'  const arc = d3.arc()\n' ||\n'      .innerRadius(innerRadius)\n' ||\n'      .outerRadius(outerRadius);\n\n' ||\n\n'  const ribbon = d3.ribbon()\n' ||\n'      .radius(innerRadius - 1)\n' ||\n'      .padAngle(0.01);\n\n' ||\n\n'  const color = d3.scaleOrdinal(names, colors);\n\n' ||\n\n'  const svg = d3.create(\"svg\")\n' ||\n'      .attr(\"width\", width)\n' ||\n'      .attr(\"height\", height)\n' ||\n'      .attr(\"viewBox\", [-width / 2, -height / 2, width, height])\n' ||\n'      .attr(\"style\", \"width: 100%; height: auto; font: 10px sans-serif;\");\n\n' ||\n\n'  const chords = chord(chordData);\n\n' ||\n\n'  const group = svg.append(\"g\")\n' ||\n'    .selectAll(\"g\")\n' ||\n'    .data(chords.groups)\n' ||\n'    .join(\"g\");\n\n' ||\n\n'  group.append(\"path\")\n' ||\n'      .attr(\"fill\", d => color(names[d.index]))\n' ||\n'      .attr(\"d\", arc);\n\n' ||\n\n'  group.append(\"title\")\n' ||\n'      .text(d => `${names[d.index]}\n${formatValue(d.value)}`);\n\n' ||\n\n'  const groupTick = group.append(\"g\")\n' ||\n'    .selectAll(\"g\")\n' ||\n'    .data(d => groupTicks(d, tickStep))\n' ||\n'    .join(\"g\")\n' ||\n'      .attr(\"transform\", d => `rotate(${d.angle * 180 / Math.PI - 90}) translate(${outerRadius},0)`);\n\n' ||\n\n'  groupTick.append(\"line\")\n' ||\n'      .attr(\"stroke\", \"currentColor\")\n' ||\n'      .attr(\"x2\", 6);\n\n' ||\n\n'  groupTick.append(\"text\")\n' ||\n'      .attr(\"x\", 8)\n' ||\n'      .attr(\"dy\", \"0.35em\")\n' ||\n'      .attr(\"transform\", d => d.angle > Math.PI ? \"rotate(180) translate(-16)\" : null)\n' ||\n'      .attr(\"text-anchor\", d => d.angle > Math.PI ? \"end\" : null)\n' ||\n'      .text(d => formatValue(d.value));\n\n' ||\n\n'  group.select(\"text\")\n' ||\n'      .attr(\"font-weight\", \"bold\")\n' ||\n'      .text(function(d) {\n' ||\n'        return this.getAttribute(\"text-anchor\") === \"end\"\n' ||\n'            ? `\u2191 ${names[d.index]}`\n' ||\n'            : `${names[d.index]} \u2193`;\n' ||\n'      });\n\n' ||\n\n'  svg.append(\"g\")\n' ||\n'      .attr(\"fill-opacity\", 0.8)\n' ||\n'    .selectAll(\"path\")\n' ||\n'    .data(chords)\n' ||\n'    .join(\"path\")\n' ||\n'      .style(\"mix-blend-mode\", \"multiply\")\n' ||\n'      .attr(\"fill\", d => color(names[d.source.index]))\n' ||\n'      .attr(\"d\", ribbon)\n' ||\n'    .append(\"title\")\n' ||\n'      .text(d => `${formatValue(d.source.value)} ${names[d.target.index]} \u2192 ${names[d.source.index]}${\n        d.source.index === d.target.index ? \"\" : `\n${formatValue(d.target.value)} ${names[d.source.index]} \u2192 ${names[d.target.index]}`\n      }`);\n\n' ||\n\n'  return svg.node();\n' ||\n'})();\n\n' ||\n\n'thisDiv.appendChild(chordChart);',\n'\n', CHAR(10)\n));\n\n\n\nCREATE VIEW V_TEMPV\nAS SELECT 1;\n\nCOMMIT TRANSACTION;\n",
    "SCL_Model": "BEGIN TRANSACTION;\n\n\n-- Table  I_BOMRecipe\nDROP TABLE IF EXISTS I_BOMRecipe;\nCREATE TABLE I_BOMRecipe (\n    BOMId           VARCHAR,\n    ItemId          VARCHAR,\n    LocationId      VARCHAR,\n    UsageQuantity   NUMERIC\n);\nINSERT INTO I_BOMRecipe VALUES('BOM_FG_1_MFG_IM1','IM_A','MFG_IM1',1);\nINSERT INTO I_BOMRecipe VALUES('BOM_FG_1_MFG_IM2','IM_A','MFG_IM2',1);\nINSERT INTO I_BOMRecipe VALUES('BOM_IM_A_MFG_IM1','API_X','MFG_IM1',1);\nINSERT INTO I_BOMRecipe VALUES('BOM_IM_A_MFG_IM2','API_X','MFG_IM2',1);\n\n-- Table  I_ForecastOrders\nDROP TABLE IF EXISTS I_ForecastOrders;\nCREATE TABLE I_ForecastOrders (\n    OrderId             VARCHAR,\n    ItemId              VARCHAR,\n    LocationId          VARCHAR,\n    ForecastArrivalDate VARCHAR,\n    Quantity            NUMERIC,\n    SalesPrice          NUMERIC\n);\nINSERT INTO I_ForecastOrders VALUES('ORDER_079','FG_1','CustomerA','2024-01-01',73,100);\nINSERT INTO I_ForecastOrders VALUES('ORDER_080','FG_1','CustomerA','2024-02-01',42,100);\nINSERT INTO I_ForecastOrders VALUES('ORDER_081','FG_1','CustomerA','2024-03-01',68,100);\nINSERT INTO I_ForecastOrders VALUES('ORDER_082','FG_1','CustomerA','2024-04-01',27,100);\nINSERT INTO I_ForecastOrders VALUES('ORDER_083','FG_1','CustomerA','2024-05-01',95,100);\nINSERT INTO I_ForecastOrders VALUES('ORDER_084','FG_1','CustomerA','2024-06-01',52,100);\nINSERT INTO I_ForecastOrders VALUES('ORDER_085','FG_1','CustomerA','2024-07-01',33,100);\nINSERT INTO I_ForecastOrders VALUES('ORDER_086','FG_1','CustomerA','2024-08-01',85,100);\nINSERT INTO I_ForecastOrders VALUES('ORDER_087','FG_1','CustomerA','2024-09-01',61,100);\nINSERT INTO I_ForecastOrders VALUES('ORDER_088','FG_1','CustomerA','2024-10-01',17,100);\nINSERT INTO I_ForecastOrders VALUES('ORDER_089','FG_1','CustomerA','2024-11-01',94,100);\nINSERT INTO I_ForecastOrders VALUES('ORDER_090','FG_1','CustomerA','2024-12-01',78,100);\nINSERT INTO I_ForecastOrders VALUES('ORDER_091','FG_1','CustomerA','2025-01-01',36,100);\nINSERT INTO I_ForecastOrders VALUES('ORDER_092','FG_1','CustomerA','2025-02-01',69,100);\nINSERT INTO I_ForecastOrders VALUES('ORDER_093','FG_1','CustomerA','2025-03-01',23,100);\nINSERT INTO I_ForecastOrders VALUES('ORDER_094','FG_1','CustomerA','2025-04-01',42,100);\nINSERT INTO I_ForecastOrders VALUES('ORDER_095','FG_1','CustomerA','2025-05-01',87,100);\nINSERT INTO I_ForecastOrders VALUES('ORDER_096','FG_1','CustomerA','2025-06-01',57,100);\nINSERT INTO I_ForecastOrders VALUES('ORDER_097','FG_1','CustomerA','2025-07-01',13,100);\nINSERT INTO I_ForecastOrders VALUES('ORDER_098','FG_1','CustomerA','2025-08-01',81,100);\nINSERT INTO I_ForecastOrders VALUES('ORDER_099','FG_1','CustomerA','2025-09-01',45,100);\nINSERT INTO I_ForecastOrders VALUES('ORDER_100','FG_1','CustomerA','2025-10-01',29,100);\nINSERT INTO I_ForecastOrders VALUES('ORDER_101','FG_1','CustomerA','2025-11-01',76,100);\nINSERT INTO I_ForecastOrders VALUES('ORDER_102','FG_1','CustomerA','2025-12-01',39,100);\nINSERT INTO I_ForecastOrders VALUES('ORDER_103','FG_1','CustomerB','2024-01-01',62,100);\nINSERT INTO I_ForecastOrders VALUES('ORDER_104','FG_1','CustomerB','2024-02-01',21,100);\nINSERT INTO I_ForecastOrders VALUES('ORDER_105','FG_1','CustomerB','2024-03-01',95,100);\nINSERT INTO I_ForecastOrders VALUES('ORDER_106','FG_1','CustomerB','2024-04-01',54,100);\nINSERT INTO I_ForecastOrders VALUES('ORDER_107','FG_1','CustomerB','2024-05-01',36,100);\nINSERT INTO I_ForecastOrders VALUES('ORDER_108','FG_1','CustomerB','2024-06-01',73,100);\nINSERT INTO I_ForecastOrders VALUES('ORDER_109','FG_1','CustomerB','2024-07-01',47,100);\nINSERT INTO I_ForecastOrders VALUES('ORDER_110','FG_1','CustomerB','2024-08-01',18,100);\nINSERT INTO I_ForecastOrders VALUES('ORDER_111','FG_1','CustomerB','2024-09-01',86,100);\nINSERT INTO I_ForecastOrders VALUES('ORDER_112','FG_1','CustomerB','2024-10-01',38,100);\nINSERT INTO I_ForecastOrders VALUES('ORDER_113','FG_1','CustomerB','2024-11-01',69,100);\nINSERT INTO I_ForecastOrders VALUES('ORDER_114','FG_1','CustomerB','2024-12-01',32,100);\nINSERT INTO I_ForecastOrders VALUES('ORDER_115','FG_1','CustomerB','2025-01-01',79,100);\nINSERT INTO I_ForecastOrders VALUES('ORDER_116','FG_1','CustomerB','2025-02-01',43,100);\nINSERT INTO I_ForecastOrders VALUES('ORDER_117','FG_1','CustomerB','2025-03-01',83,100);\nINSERT INTO I_ForecastOrders VALUES('ORDER_118','FG_1','CustomerB','2025-04-01',56,100);\nINSERT INTO I_ForecastOrders VALUES('ORDER_119','FG_1','CustomerB','2025-05-01',88,100);\nINSERT INTO I_ForecastOrders VALUES('ORDER_120','FG_1','CustomerB','2025-06-01',49,100);\nINSERT INTO I_ForecastOrders VALUES('ORDER_121','FG_1','CustomerB','2025-07-01',59,100);\nINSERT INTO I_ForecastOrders VALUES('ORDER_122','FG_1','CustomerB','2025-08-01',43,100);\nINSERT INTO I_ForecastOrders VALUES('ORDER_123','FG_1','CustomerB','2025-09-01',73,100);\nINSERT INTO I_ForecastOrders VALUES('ORDER_124','FG_1','CustomerB','2025-10-01',81,100);\nINSERT INTO I_ForecastOrders VALUES('ORDER_125','FG_1','CustomerB','2025-11-01',72,100);\nINSERT INTO I_ForecastOrders VALUES('ORDER_126','FG_1','CustomerB','2025-12-01',43,100);\n\n-- Table  I_ForecastRegistration\nDROP TABLE IF EXISTS I_ForecastRegistration;\nCREATE TABLE I_ForecastRegistration (\n    ForecastItemId       VARCHAR,\n    ItemId               VARCHAR,\n    LocationId\t\t     VARCHAR,\n    StartDate\t\t\t VARCHAR,\n    EndDate\t\t\t     VARCHAR\n);\n\n-- Table  I_InventoryPolicy\nDROP TABLE IF EXISTS I_InventoryPolicy;\nCREATE TABLE I_InventoryPolicy (\n    ItemId                      VARCHAR,\n    LocationId                  VARCHAR,\n    InventoryType               VARCHAR,\n    IsProduction                INTEGER DEFAULT 0,\n    IsStorage                   INTEGER DEFAULT 0,\n    InventoryUnitCost           NUMERIC,\n    InventoryHoldingCost        NUMERIC,\n    SalesPrice                  NUMERIC,\n    SafetyStockDOS              NUMERIC DEFAULT (0),\n    DOSWindow                   NUMERIC DEFAULT (0),\n    InventoryShelfLife          NUMERIC,\n    MinReleaseTime              NUMERIC,\n    MinEndingInventory          NUMERIC DEFAULT (0),\n    MaxEndingInventory          VARCHAR DEFAULT ('INF'),\n    MinProductionQuantity       NUMERIC DEFAULT (0),\n    MaxProductionQuantity       VARCHAR DEFAULT ('INF'),\n    InventoryStatus             INTEGER DEFAULT (1)\n);\nINSERT INTO I_InventoryPolicy VALUES('FG_1','CustomerA','Customer',0,1,50,NULL,100,0,0,NULL,NULL,0,'INF',0,'INF',1);\nINSERT INTO I_InventoryPolicy VALUES('FG_1','CustomerB','Customer',0,1,50,NULL,100,0,0,NULL,NULL,0,'INF',0,'INF',1);\nINSERT INTO I_InventoryPolicy VALUES('FG_1','MFG_IM1','Plant',1,0,50,NULL,100,0,0,NULL,NULL,0,'INF',0,'INF',1);\nINSERT INTO I_InventoryPolicy VALUES('FG_1','MFG_IM2','Plant',1,0,50,NULL,100,0,0,NULL,NULL,0,'INF',0,'INF',1);\nINSERT INTO I_InventoryPolicy VALUES('IM_A','MFG_IM1','Plant',1,1,20,NULL,NULL,0,0,NULL,NULL,0,'INF',0,'INF',1);\nINSERT INTO I_InventoryPolicy VALUES('IM_A','MFG_IM2','Plant',1,1,20,NULL,NULL,0,0,NULL,NULL,0,'INF',0,'INF',1);\nINSERT INTO I_InventoryPolicy VALUES('API_X','MFG_IM1','ProductLocation',0,1,5,NULL,NULL,0,0,NULL,NULL,0,'INF',0,'INF',1);\nINSERT INTO I_InventoryPolicy VALUES('API_X','MFG_IM2','ProductLocation',0,1,5,NULL,NULL,0,0,NULL,NULL,0,'INF',0,'INF',1);\nINSERT INTO I_InventoryPolicy VALUES('API_X','MFG_API','Plant',1,0,5,NULL,NULL,0,0,NULL,NULL,0,'INF',0,'INF',1);\n\n-- Table  I_InventoryPolicyPerPeriod\nDROP TABLE IF EXISTS I_InventoryPolicyPerPeriod;\nCREATE TABLE I_InventoryPolicyPerPeriod (\n    ItemId                VARCHAR,\n    LocationId            VARCHAR,\n    StartDate             VARCHAR,\n    MinEndingInventory    NUMERIC DEFAULT (0),\n    MaxEndingInventory    VARCHAR DEFAULT ('INF'),\n    MinProductionQuantity NUMERIC DEFAULT (0),\n    MaxProductionQuantity VARCHAR DEFAULT ('INF'),\n    SafetyStockDOS        NUMERIC\n);\n\n-- Table  I_ItemMaster\nDROP TABLE IF EXISTS I_ItemMaster;\nCREATE TABLE I_ItemMaster (\n    ItemId                VARCHAR,\n    ItemDescription       VARCHAR,\n    ItemType              VARCHAR,\n    SalesPrice            NUMERIC,\n    UnitCost              NUMERIC,\n    Brand                 VARCHAR,\n    SubBrand              VARCHAR,\n    Category              VARCHAR,\n    SubCategory           VARCHAR,\n    ItemStatus            INTEGER DEFAULT 1 \n);\nINSERT INTO I_ItemMaster VALUES('FG_1','Finshed Goods','FG',100,50,NULL,NULL,NULL,NULL,1);\nINSERT INTO I_ItemMaster VALUES('IM_A','Intermediate Product','IM',NULL,20,NULL,NULL,NULL,NULL,1);\nINSERT INTO I_ItemMaster VALUES('API_X','API','API',NULL,5,NULL,NULL,NULL,NULL,1);\n\n-- Table  I_LocationMaster\nDROP TABLE IF EXISTS I_LocationMaster;\nCREATE TABLE I_LocationMaster (\n    LocationId          VARCHAR,\n    LocationType        VARCHAR,\n    LocationCategory    VARCHAR,\n    LocationAttribute1  VARCHAR,\n    LocationAttribute2  VARCHAR,\n    Region              VARCHAR,\n    Country             VARCHAR,\n    State               VARCHAR,\n    City                VARCHAR,\n    ZipCode             VARCHAR,\n    Longitude           NUMERIC,\n    Latitude            NUMERIC\n);\nINSERT INTO I_LocationMaster VALUES('CustomerA','Customer',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);\nINSERT INTO I_LocationMaster VALUES('CustomerB','Customer',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);\nINSERT INTO I_LocationMaster VALUES('MFG_API','Facility',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);\nINSERT INTO I_LocationMaster VALUES('MFG_IM1','Facility',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);\nINSERT INTO I_LocationMaster VALUES('MFG_IM2','Facility',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);\n\n-- Table  I_ModelSetup\nDROP TABLE IF EXISTS I_ModelSetup;\nCREATE TABLE I_ModelSetup (\n    ModelName        VARCHAR,\n    StartDate        VARCHAR,\n    TimeFrequency    VARCHAR,\n    NumberOfPeriods  NUMERIC,\n    InterestRate     NUMERIC DEFAULT (0.12),\n    DOSWindowStartPeriod INTEGER DEFAULT (1) \n);\nINSERT INTO I_ModelSetup VALUES('SCL Test Model','2024-01-01','Monthly',24,0.01,1);\n\n-- Table  I_OpeningStocks\nDROP TABLE IF EXISTS I_OpeningStocks;\nCREATE TABLE I_OpeningStocks (\n    StockId      VARCHAR,\n    ItemId       VARCHAR,\n    LocationId   VARCHAR,\n    Quantity     NUMERIC,\n    EntryDate    VARCHAR,\n    ExpiryDate   VARCHAR DEFAULT (72686) \n);\nINSERT INTO I_OpeningStocks VALUES('STOCK_001','FG_1','CustomerA',11,'2024-01-01','2099-01-01');\nINSERT INTO I_OpeningStocks VALUES('STOCK_002','FG_1','CustomerB',23,'2024-01-01','2099-01-01');\nINSERT INTO I_OpeningStocks VALUES('STOCK_003','IM_A','MFG_IM1',22,'2024-01-01','2099-01-01');\nINSERT INTO I_OpeningStocks VALUES('STOCK_004','IM_A','MFG_IM2',15,'2024-01-01','2099-01-01');\nINSERT INTO I_OpeningStocks VALUES('STOCK_005','API_X','MFG_IM1',18,'2024-01-01','2099-01-01');\nINSERT INTO I_OpeningStocks VALUES('STOCK_006','API_X','MFG_IM2',10,'2024-01-01','2099-01-01');\n\n-- Table  I_Processes\nDROP TABLE IF EXISTS I_Processes;\nCREATE TABLE I_Processes (\n    ProcessId          VARCHAR,\n    ProcessStep        VARCHAR,\n    ItemId             VARCHAR,\n    LocationId         VARCHAR,\n    BOMId              VARCHAR,\n    ResourceId         VARCHAR,\n    UnitOperationTime  NUMERIC,\n    UnitOperationCost  NUMERIC,\n    Yield              NUMERIC DEFAULT 1,\n    MOQ                NUMERIC,\n    PersonnelTime      NUMERIC,\n    LotSizeRounding    NUMERIC,\n    MinSplitRatio      NUMERIC,\n    MaxSplitRatio      NUMERIC\n);\nINSERT INTO I_Processes VALUES('PR_FG_1_MFG_IM1','0','FG_1','MFG_IM1','BOM_FG_1_MFG_IM1','RS_MFG_IM1',1,NULL,1,NULL,NULL,NULL,NULL,NULL);\nINSERT INTO I_Processes VALUES('PR_FG_1_MFG_IM2','0','FG_1','MFG_IM2','BOM_FG_1_MFG_IM2','RS_MFG_IM2',1,NULL,1,NULL,NULL,NULL,NULL,NULL);\nINSERT INTO I_Processes VALUES('PR_IM_A_MFG_IM1','0','IM_A','MFG_IM1','BOM_IM_A_MFG_IM1','RS_MFG_IM1',1,NULL,1,NULL,NULL,NULL,NULL,NULL);\nINSERT INTO I_Processes VALUES('PR_IM_A_MFG_IM2','0','IM_A','MFG_IM2','BOM_IM_A_MFG_IM2','RS_MFG_IM2',1,NULL,1,NULL,NULL,NULL,NULL,NULL);\nINSERT INTO I_Processes VALUES('PR_API_X_MFG_API','0','API_X','MFG_API',NULL,'RS_MFG_API',1,NULL,1,NULL,NULL,NULL,NULL,NULL);\n\n-- Table  I_ProcessesPerPeriod\nDROP TABLE IF EXISTS I_ProcessesPerPeriod;\nCREATE TABLE I_ProcessesPerPeriod (\n    ProcessId          VARCHAR,\n    ProcessStep        VARCHAR,\n    ItemId             VARCHAR,\n    LocationId         VARCHAR,\n    StartDate          VARCHAR,\n    UnitOperationTime  NUMERIC,\n    Yield              NUMERIC DEFAULT 1,\n    MinSplitRatio      NUMERIC,\n    MaxSplitRatio      NUMERIC\n);\n\n-- Table  I_ResourceMaster\nDROP TABLE IF EXISTS I_ResourceMaster;\nCREATE TABLE I_ResourceMaster (\n    ResourceId            VARCHAR,\n    ResourceDescription   VARCHAR,\n    LocationId            VARCHAR,\n    ResourceUOM           VARCHAR,\n    SupplyCapacity        VARCHAR DEFAULT ('INF'),\n    MinUtilization        NUMERIC DEFAULT (0),\n    MaxUtilization        VARCHAR DEFAULT ('1'),\n    ResourceStatus        INTEGER DEFAULT (1)\n);\nINSERT INTO I_ResourceMaster VALUES('RS_MFG_IM1','RS_MFG_IM1','MFG_IM1','HRS','INF',0,'1',1);\nINSERT INTO I_ResourceMaster VALUES('RS_MFG_IM2','RS_MFG_IM2','MFG_IM2','HRS','INF',0,'1',1);\nINSERT INTO I_ResourceMaster VALUES('RS_MFG_API','RS_MFG_API','MFG_API','HRS','INF',0,'1',1);\n\n-- Table  I_ResourcePerPeriod\nDROP TABLE IF EXISTS I_ResourcePerPeriod;\nCREATE TABLE I_ResourcePerPeriod (\n    ResourceId     VARCHAR,\n    StartDate      VARCHAR,\n    SupplyCapacity VARCHAR,\n    MinUtilization NUMERIC,\n    MaxUtilization VARCHAR\n);\n\n-- Table  I_TransportationPolicy\nDROP TABLE IF EXISTS I_TransportationPolicy;\nCREATE TABLE I_TransportationPolicy (\n    ItemId                  VARCHAR,\n    FromLocationId          VARCHAR,\n    ToLocationId            VARCHAR,\n    ModeId                  VARCHAR,\n    UnitTransportationCost  NUMERIC,\n    TransportationLeadTime  NUMERIC,\n    MinQuantity             NUMERIC,\n    MaxQuantity             NUMERIC,\n    MinSplitRatio           NUMERIC,\n    MaxSplitRatio           NUMERIC \n);\nINSERT INTO I_TransportationPolicy VALUES('FG_1','MFG_IM1','CustomerA','Truck',5,30,NULL,NULL,NULL,NULL);\nINSERT INTO I_TransportationPolicy VALUES('FG_1','MFG_IM1','CustomerB','Truck',3,60,NULL,NULL,NULL,NULL);\nINSERT INTO I_TransportationPolicy VALUES('FG_1','MFG_IM2','CustomerA','Truck',3,60,NULL,NULL,NULL,NULL);\nINSERT INTO I_TransportationPolicy VALUES('FG_1','MFG_IM2','CustomerB','Truck',4,30,NULL,NULL,NULL,NULL);\nINSERT INTO I_TransportationPolicy VALUES('API_X','MFG_API','MFG_IM1','Truck',5,30,NULL,NULL,NULL,NULL);\nINSERT INTO I_TransportationPolicy VALUES('API_X','MFG_API','MFG_IM2','Truck',5,30,NULL,NULL,NULL,NULL);\n\n-- Table  I_TransportationPolicyPerPeriod\nDROP TABLE IF EXISTS I_TransportationPolicyPerPeriod;\nCREATE TABLE I_TransportationPolicyPerPeriod (\n    ItemId                  VARCHAR,\n    FromLocationId          VARCHAR,\n    ToLocationId            VARCHAR,\n    ModeId                  VARCHAR,\n    StartDate               VARCHAR,\n    MinQuantity             NUMERIC DEFAULT (0),\n    MaxQuantity             VARCHAR DEFAULT ('INF'),\n    MinSplitRatio           NUMERIC,\n    MaxSplitRatio           NUMERIC \n);\n\n-- Table  O_DemandAnalysis\nDROP TABLE IF EXISTS O_DemandAnalysis;\nCREATE TABLE O_DemandAnalysis (\n    ItemId                 VARCHAR,\n    LocationId             VARCHAR,\n    FulFilledQuantity      NUMERIC,\n    Quantity               NUMERIC,\n    Iteration              INTEGER\n);\n\n-- Table  O_ForecastRegistration\nDROP TABLE IF EXISTS O_ForecastRegistration;\nCREATE TABLE O_ForecastRegistration (\n    ItemId                 VARCHAR,\n    LocationId             VARCHAR,\n    StartDate              VARCHAR,\n    ForecastItemId         VARCHAR,\n    SatisfiedQuantity      NUMERIC\n);\n\n-- Table  O_InitialInventory\nDROP TABLE IF EXISTS O_InitialInventory;\nCREATE TABLE O_InitialInventory (\n    ItemId                  VARCHAR,\n    LocationId              VARCHAR,\n    Quantity                NUMERIC\n);\n\n-- Table  O_Inventory\nDROP TABLE IF EXISTS O_Inventory;\nCREATE TABLE O_Inventory (\n    ItemId                  VARCHAR,\n    LocationId              VARCHAR,\n    StartDate               VARCHAR,\n    OpeningInventory        NUMERIC,\n    IncomingStock           NUMERIC,\n    EndingInventory         NUMERIC,\n    InTransitInventory      NUMERIC,\n    InReleaseInventory      NUMERIC,\n    ShortFallInventory      NUMERIC,\n    InboundStock            NUMERIC,\n    OutboundStock           NUMERIC,\n    ProductionQuantity      NUMERIC,\n    OrderedQuantity         NUMERIC,\n    ConsumedQuantity        NUMERIC,\n    ExpiredQuanity          NUMERIC,\n    SatisfiedDemand         NUMERIC,\n    Demand                  NUMERIC,\n    RegistrationOutbound    NUMERIC,\n    RegistrationInbound     NUMERIC,\n    RequiredInventory       NUMERIC\n);\n\n-- Table  O_ModelValidation\nDROP TABLE IF EXISTS O_ModelValidation;\nCREATE TABLE O_ModelValidation (\n    TableName       VARCHAR,\n    ColumnName     VARCHAR,\n    ColumnValue     VARCHAR,\n    ErrorType       VARCHAR,\n    ErrorMsg        VARCHAR\n);\n\n-- Table  O_Objective\nDROP TABLE IF EXISTS O_Objective;\nCREATE TABLE O_Objective (\n    SolveStatus            VARCHAR,\n    ObjectiveName          VARCHAR,\n    ObjectiveValue         NUMERIC,\n    LastUpdateDate         VARCHAR DEFAULT (datetime('now', 'localtime') )\n);\n\n-- Table  O_Period\nDROP TABLE IF EXISTS O_Period;\nCREATE TABLE O_Period (\n    PeriodIdx              INTEGER,\n    PeriodStart            VARCHAR,\n    PeriodEnd              VARCHAR,\n    PeriodMonth            VARCHAR,\n    PeriodQuarter          VARCHAR,\n    PeriodYear             VARCHAR,\n    PeriodDays             NUMERIC\n);\n\n-- Table  O_Production\nDROP TABLE IF EXISTS O_Production;\nCREATE TABLE O_Production (\n    ItemId                 VARCHAR,\n    LocationId             VARCHAR,\n    ProcessId              VARCHAR,\n    StartDate              VARCHAR,\n    ProductionQuantity     NUMERIC,\n    ProductionCost         NUMERIC\n);\n\n-- Table  O_Transportation\nDROP TABLE IF EXISTS O_Transportation;\nCREATE TABLE O_Transportation (\n    ItemId                  VARCHAR,\n    FromLocationId          VARCHAR,\n    ToLocationId            VARCHAR,\n    StartDate               VARCHAR,\n    EndDate                 VARCHAR,\n    ModeId                  VARCHAR,\n    FlowQuantity            NUMERIC,\n    FlowTransportationCost  NUMERIC\n);\n\n-- Table  S_DataFiles\nDROP TABLE IF EXISTS S_DataFiles;\nCREATE TABLE S_DataFiles (\n\tFileId\t            INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n\tFileName\t        VARCHAR,\n\tFileType   \t        VARCHAR,\n    FileBlob            BLOB NOT NULL,\n\tStatus\t            VARCHAR DEFAULT ('Active'),\n    UNIQUE(FileName,FileType)\t\n);\n\n-- Table  S_ExecutionFiles\nDROP TABLE IF EXISTS S_ExecutionFiles;\nCREATE TABLE S_ExecutionFiles (\n\tFileId\t            INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n\tFileName\t        VARCHAR,\n\tFileLabel   \t    VARCHAR,\n    FilePath            VARCHAR UNIQUE,\n    FileData            VARCHAR,\n\tStatus\t            VARCHAR DEFAULT ('Active')\t\n);\nINSERT INTO S_ExecutionFiles VALUES(1,'clean_model.py',NULL,'clean_model.py','import sys\nfrom cl_compute.sql_connector import sql_connect\nfrom cl_compute.utilityMethods.clean_model import main as clean_model\n\n\nif sys.platform != ''emscripten'':\n    thisDB = r\"C:\\Users\\akhil\\Downloads\\SCL.sqlite3\"\n\nwith sql_connect(thisDB) as conn:\n    conn.execute(\"DELETE FROM T_SolverLog\")\n    clean_model(conn)','Active');\nINSERT INTO S_ExecutionFiles VALUES(2,'optimize.py',NULL,'optimize.py','import sys\nfrom cl_compute.sql_connector import sql_connect\nfrom cl_compute.optimization.main import main as optimize\n\n\nif sys.platform != ''emscripten'':\n    thisDB = r\"C:\\Users\\akhil\\Downloads\\SCL.sqlite3\"\n\nwith sql_connect(thisDB) as conn:\n    conn.execute(\"DELETE FROM T_SolverLog\")\n    optimize(conn)','Active');\nINSERT INTO S_ExecutionFiles VALUES(3,'propagate_demand.py',NULL,'propagate_demand.py','import sys\nfrom cl_compute.sql_connector import sql_connect\nfrom cl_compute.utilityMethods.propogate_demand import main as propogate_demand\n\n\nif sys.platform != ''emscripten'':\n    thisDB = r\"C:\\Users\\akhil\\Downloads\\SCL.sqlite3\"\n\nwith sql_connect(thisDB) as conn:\n    conn.execute(\"DELETE FROM T_SolverLog\")\n    propogate_demand(conn)','Active');\nINSERT INTO S_ExecutionFiles VALUES(4,'requirements.txt',NULL,'requirements.txt','apsw\npulp\nhighspy','Active');\nINSERT INTO S_ExecutionFiles VALUES(5,'validate_model.py',NULL,'validate_model.py','import sys\nfrom cl_compute.sql_connector import sql_connect\nfrom cl_compute.utilityMethods.validate_model import main as validate_model\n\nif sys.platform != ''emscripten'':\n    thisDB = r\"C:\\Users\\akhil\\Downloads\\SCL.sqlite3\"\n\nwith sql_connect(thisDB) as conn:\n    conn.execute(\"DELETE FROM T_SolverLog\")\n    validate_model(conn)','Active');\nINSERT INTO S_ExecutionFiles VALUES(6,'sql_connector.py',NULL,'cl_compute/sql_connector.py','import apsw\n\nclass sql_connect():\n    def __init__(self, db_name: str):\n        self.cursor = get_cursor(db_name)\n        self.db_name = db_name\n\n    def __enter__(self):\n        self.cursor.execute(\"begin\")\n        return scc_cursor(self.cursor, self.db_name)\n\n    def __exit__(self, exception_type, exception_value, traceback_val):\n        if exception_type:\n            try:\n                self.cursor.execute(\"ROLLBACK\")\n            except:\n                pass\n            self.cursor.close()\n        else:\n            self.cursor.execute(\"COMMIT\")\n            self.cursor.close()\n\n\ndef get_cursor(db_name):\n    connection = apsw.Connection(db_name)\n    return connection.cursor()\n\n\nclass scc_cursor():\n    def __init__(self, conn, db_name):\n        self.conn = conn\n        self.db_name = db_name\n\n    def execute(self, query, args=tuple()):\n        try:\n            self.conn.execute(query, args)\n        except Exception as ex:\n            print(f\"query: {query}\")\n            if len(args) > 0:\n                print(f\"arguments: {args}\")\n            raise ex\n        return self.conn\n\n    def intermediate_commit(self):\n        try:\n            self.conn.execute(\"COMMIT\")\n            self.conn.execute(\"BEGIN\")\n        except Exception as ex:\n            raise Exception(f\"Error occured {ex}\")\n\ndef insert_log(conn, message_str):\n    print(message_str)\n    query = \"insert into T_SolverLog (LogMessage) values (?)\"\n    conn.execute(query, (message_str,))\n    conn.intermediate_commit()','Active');\nINSERT INTO S_ExecutionFiles VALUES(7,'import_output.py',NULL,'cl_compute/optimization/import_output.py','from .output_queries import *\nfrom .queries import ss_sql\nfrom ..sql_connector import insert_log\n\ndef round_fn(val):\n    if val is None:\n        return 0\n    else:\n        return round(val, 5)\n    \n\ndef get_val(val):\n    if val is None:\n        return 0\n    if hasattr(val, \"varValue\"):\n        if val.varValue is None:\n            return 0\n        return val.varValue\n    return val\n\ndef main(conn, demand_dict, inventory_dict, reg_demand_dict, process_dict, \n         flow_dict, inbound_flow, dem_shortfall, inv_shortfall, all_combinations, periods, \n         initial_inv, bom_var, expiry_var):\n    delete_output_tables(conn)\n    insert_log(conn, \"Output import started\")\n\n    ss_requirement = {}\n    query = \"select DOSWindowStartPeriod from I_ModelSetup\"\n    n = conn.execute(query).fetchone()[0]\n\n    for item, location, period, prd_idx, dos_window, ss_req in conn.execute(ss_sql):\n        dos_periods = periods[prd_idx+n: prd_idx+n+int(dos_window)]\n        ct = int(dos_window)\n        if ct == 0:\n            continue\n        out_flow = sum(get_val(flow_dict[item][location][to_location][mode][period])\n                            for to_location in flow_dict.get(item, {}).get(location, {})\n                            for mode in flow_dict[item][location][to_location]\n                            for period in flow_dict[item][location][to_location][mode]\n                            if period in dos_periods)/ct + \\\n                    sum(get_val(demand_dict[item][location][period][''var''])\n                            for period in demand_dict.get(item, {}).get(location, {})\n                            if period in dos_periods)/ct + \\\n                    sum(get_val(bom_var[item][location][period])\n                            for period in bom_var.get(item, {}).get(location, {})\n                            if period in dos_periods)/ct + \\\n                    sum(get_val(reg_demand_dict[item][location][period][demand_item])\n                            for period in dos_periods \n                            for demand_item in reg_demand_dict.get(item, {}).get(location, {}).get(period, {}))/ct\n        req = round(ss_req * out_flow, 5)\n        if item not in ss_requirement:\n            ss_requirement[item] = {location: {period: req}}\n        elif location not in ss_requirement[item]:\n            ss_requirement[item][location] = {period: req}\n        else:\n            ss_requirement[item][location][period] = req\n\n\n    for item, location in all_combinations:\n        for period_idx, period in enumerate(periods):\n            opening_inv = get_val(initial_inv.get(item, {}).get(location, {}).get(period, 0))\n            incoming_stock = 0\n            if period_idx > 0:\n                incoming_stock = opening_inv\n                opening_inv += get_val(inventory_dict.get(item, {}).get(location, {}).get(periods[period_idx-1], 0))\n            closing_inv = get_val(inventory_dict.get(item, {}).get(location, {}).get(period, 0))\n            prod_qty = get_val(sum(process_dict[item][location][process][period].varValue\n                                    for process in process_dict.get(item, {}).get(location, {})\n                                    if period in process_dict[item][location][process]))\n            shortfall_qty = get_val(inv_shortfall.get(item, {}).get(location, {}).get(period, 0))\n            inbound_qty = sum(get_val(inbound_flow[item][from_location][location][mode][period])\n                                    for from_location in inbound_flow.get(item, {})\n                                    if location in inbound_flow[item][from_location]\n                                    for mode in inbound_flow[item][from_location][location]\n                                    if period in inbound_flow[item][from_location][location][mode])\n            \n            outbound_qty = get_val(sum(flow_dict[item][location][to_location][mode][period].varValue\n                                        for to_location in flow_dict.get(item, {}).get(location, {})\n                                        for mode in flow_dict[item][location][to_location]\n                                        if period in flow_dict[item][location][to_location][mode]))\n            satisfied_qty = get_val(demand_dict.get(item, {}).get(location, {}).get(period, \n                                                                                 {}).get(''var'', 0))\n            demand_qty = get_val(demand_dict.get(item, {}).get(location, {}).get(period, \n                                                                                 {}).get(''max'', 0))\n            reg_inbound = get_val(sum(reg_demand_dict[reg_item][location][period][item].varValue\n                                    for reg_item in reg_demand_dict\n                                    if location in reg_demand_dict[reg_item]\n                                    if period in reg_demand_dict[reg_item][location]\n                                    if item in reg_demand_dict[reg_item][location][period]))\n            reg_outbound = get_val(sum(reg_demand_dict[item][location][period][demand_item].varValue\n                                    for demand_item in reg_demand_dict.get(item, \n                                            {}).get(location, {}).get(period, {})))\n            consumed_qty = get_val(bom_var.get(item, {}).get(location, {}).get(period, 0))\n            expired_qty = get_val(sum(var.varValue for var in \n                                expiry_var.get(item, {}).get(location, {}).get(period, [])))\n            required_inventory = ss_requirement.get(item, {}).get(location, {}).get(period, 0)\n            opening_inv = round(opening_inv, 5)\n            closing_inv = round(closing_inv, 5)\n            shortfall_qty = round(shortfall_qty, 5)\n            inbound_qty = round(inbound_qty, 5)\n            outbound_qty = round(outbound_qty, 5)\n            prod_qty = round(prod_qty, 5)\n            satisfied_qty = round(satisfied_qty, 5)\n            demand_qty = round(demand_qty, 5)\n            reg_inbound = round(reg_inbound, 5)\n            reg_outbound = round(reg_outbound, 5)\n            consumed_qty = round(consumed_qty, 5)\n            required_inventory = round(required_inventory, 5)\n            incoming_stock = round(incoming_stock, 5)\n            insert_tpl = (item, location, period, opening_inv, closing_inv, shortfall_qty, \n                          inbound_qty, outbound_qty, prod_qty, satisfied_qty, demand_qty, reg_inbound, \n                         reg_outbound, consumed_qty, required_inventory, incoming_stock, expired_qty)\n            conn.execute(inventory_sql, insert_tpl)\n    \n    for item in reg_demand_dict:\n        for location in reg_demand_dict[item]:\n            for period in reg_demand_dict[item][location]:\n                for demand_item in reg_demand_dict[item][location][period]:\n                    demand_qty = round_fn(reg_demand_dict[item][location][period][demand_item].varValue)\n                    if demand_qty > 0:\n                        insert_tpl = (item, location, period, demand_item, demand_qty)\n                        conn.execute(reg_sql, insert_tpl)\n                        \n    for item in process_dict:\n        for location in process_dict[item]:\n            for process in process_dict[item][location]:\n                for period in process_dict[item][location][process]:\n                    prod_qty = round_fn(process_dict[item][location][process][period].varValue)\n                    if prod_qty > 0:\n                        insert_tpl = (item, location, process, period, prod_qty)\n                        conn.execute(production_sql, insert_tpl)\n\n    for item in flow_dict:\n        for from_location in flow_dict[item]:\n            for to_location in flow_dict[item][from_location]:\n                for mode in flow_dict[item][from_location][to_location]:\n                    for period in flow_dict[item][from_location][to_location][mode]:\n                        flow_qty = round_fn(flow_dict[item][from_location][to_location][mode][period].varValue)\n                        if flow_qty > 0:\n                            insert_tpl = (item, from_location, to_location, period, mode, flow_qty)\n                            conn.execute(flow_sql, insert_tpl)\n\n    import_initial_inv(conn, initial_inv, periods[0])\n    insert_log(conn, f\"Output import completed \")\n    conn.execute(update_period_end)\n    conn.execute(update_intransit_inventory)\n    conn.execute(update_ordered_quantity)\n    conn.execute(update_production_cost)\n    conn.execute(update_transportation_cost)\n    conn.execute(update_inrelease_inventory)\n    insert_log(conn, f\"Output post processing completed\")\n\n\ndef import_initial_inv(conn, initial_inv, initial_period):\n    insert_log(conn, f\"Initial inventory import started\")\n    for item in initial_inv:\n        for location in initial_inv[item]:\n            stock = 0\n            var = initial_inv[item][location].get(initial_period, 0)\n            var_val = get_val(var)\n            stock += var_val\n            stock = round(stock, 5)\n            if stock > 0:\n                conn.execute(initial_inv_sql, (item, location, stock))\n    insert_log(conn, f\"Initial inventory import completed\")\n\ndef delete_output_tables(conn):\n    output_tables = (\"O_Inventory\", \"O_Transportation\", \"O_InitialInventory\", \n                     \"O_Production\", \"O_ForecastRegistration\")\n    for table_name in output_tables:\n        delete_query = f\"DELETE FROM [{table_name}]\"\n        conn.execute(delete_query)\n\ndef update_objective(conn, solve_status, objective_name, objective_value):\n    query = \"\"\"INSERT INTO O_Objective (SolveStatus, ObjectiveName, ObjectiveValue)\n               Values (?, ?, ?)\"\"\"\n    insert_tpl = (solve_status, objective_name, str(objective_value))\n    conn.execute(query, insert_tpl)\n    insert_log(conn, '': ''.join(insert_tpl))','Active');\nINSERT INTO S_ExecutionFiles VALUES(8,'load_constraints.py',NULL,'cl_compute/optimization/load_constraints.py','from pulp import  lpSum, LpStatus, LpVariable, LpContinuous, HiGHS\nfrom .queries import get_resource_constraint_sql, min_release_sql, ss_sql, get_production_sql\nfrom .import_output import update_objective\n\ndef add_resource_constraint(prob, conn, process_dict, resource_dict):\n    resource_relation = {}\n    for process, step, item, location, period, resource, yld, \\\n        process_time in conn.execute(get_resource_constraint_sql):\n        if resource not in resource_relation:\n            resource_relation[resource] = {location: {period: {item: {process: {step: process_time/yld}}}}}\n        elif location not in resource_relation[resource]:\n            resource_relation[resource][location] = {period: {item: {process: {step: process_time/yld}}}}\n        elif period not in resource_relation[resource][location]:\n            resource_relation[resource][location][period] = {item: {process: {step: process_time/yld}}}\n        elif item not in resource_relation[resource][location][period]:\n            resource_relation[resource][location][period][item] = {process: {step: process_time/yld}}\n        elif process not in resource_relation[resource][location][period][item]:\n            resource_relation[resource][location][period][item][process] = {step: process_time/yld}\n        else:\n            resource_relation[resource][location][period][item][process][step] = process_time/yld\n    \n    for resource in resource_relation:\n        for location in resource_relation[resource]:\n            for period in resource_relation[resource][location]:\n                prob += resource_dict[resource][location][period] == \\\n                    lpSum(resource_relation[resource][location][period][item][process][step] * \\\n                          process_dict.get(item, {}).get(location, {}).get(process, {}).get(period, 0)\n                          for item in resource_relation[resource][location][period]\n                          for process in resource_relation[resource][location][period][item]\n                          for step in resource_relation[resource][location][period][item][process]), \\\n                          f''res_const_{resource}_{location}_{period}''\n    return prob\n\n\ndef add_min_relase_time_constraint(conn, prob, periods, inventory_dict, flow_dict, demand_dict, \n                                   bom_var, initial_inv, reg_demand_dict):\n    for item, location, prd_name, prd_idx, release_time in conn.execute(min_release_sql):\n        release_time = int(round(release_time,0))\n        release_periods = periods[prd_idx+1: prd_idx+1+release_time]\n        reg_inbound = lpSum(reg_demand_dict[from_item][location][period][item]\n                            for from_item in reg_demand_dict\n                            for period in release_periods\n                            if item in reg_demand_dict[from_item].get(location, {}).get(period, {}))\n        inbound_stock = lpSum(initial_inv[item][location][period]\n                              for period in initial_inv.get(item, {}).get(location, {})\n                              if period in release_periods)\n        out_flow = lpSum(flow_dict[item][location][to_location][mode][period]\n                            for to_location in flow_dict.get(item, {}).get(location, {})\n                            for mode in flow_dict[item][location][to_location]\n                            for period in flow_dict[item][location][to_location][mode]\n                            if period in release_periods) + \\\n                    lpSum(demand_dict[item][location][period][''var'']\n                            for period in demand_dict.get(item, {}).get(location, {})\n                            if period in release_periods) + \\\n                    lpSum(bom_var[item][location][period]\n                            for period in bom_var.get(item, {}).get(location, {})\n                            if period in release_periods)\n        prob += inventory_dict[item][location][prd_name] >= out_flow - reg_inbound - inbound_stock, \\\n                f''min_release_constraint_{item}_{location}_{prd_name}''\n\n        if prd_idx == 0:\n            for partial_release_time in range(1, release_time+1):\n                release_periods = periods[prd_idx: prd_idx+partial_release_time]\n                out_flow = lpSum(flow_dict[item][location][to_location][mode][period]\n                                for to_location in flow_dict.get(item, {}).get(location, {})\n                                for mode in flow_dict[item][location][to_location]\n                                for period in flow_dict[item][location][to_location][mode]\n                                if period in release_periods) + \\\n                        lpSum(demand_dict[item][location][period][''var'']\n                                for period in demand_dict.get(item, {}).get(location, {})\n                                if period in release_periods) + \\\n                        lpSum(bom_var[item][location][period]\n                                for period in bom_var.get(item, {}).get(location, {})\n                                if period in release_periods)\n                reg_inbound = lpSum(reg_demand_dict[from_item][location][period][item]\n                                for from_item in reg_demand_dict\n                                for period in release_periods\n                                if item in reg_demand_dict[from_item].get(location, {}).get(period, {}))\n                inbound_stock = lpSum(initial_inv[item][location][period]\n                                    for period in initial_inv.get(item, {}).get(location, {})\n                                    if period in release_periods)\n                prob += inbound_stock >= out_flow - reg_inbound, \\\n                    f''min_release_constraint_{item}_{location}_{prd_name}_{partial_release_time}''\n    return prob\n\n\ndef minimize_inventory_shortfall(prob, conn, inventory_dict, flow_dict, periods, demand_dict, bom_var, \n                                 product_values, reg_demand_dict):\n    inv_shortfall = {}\n    for item in inventory_dict:\n        inv_shortfall[item] = {}\n        for location in inventory_dict[item]:\n            inv_shortfall[item][location] = {}\n            for period in inventory_dict[item][location]:\n                var = LpVariable(name=f\"inv_shortfall_{item}_{location}_{period}\", \n                                 lowBound=0, upBound=None, cat=LpContinuous)\n                inv_shortfall[item][location][period] = var\n\n    query = \"select ifnull(DOSWindowStartPeriod,1) from I_ModelSetup\"\n    n = conn.execute(query).fetchone()[0]\n    \n    optimize = False\n    for item, location, period, prd_idx, dos_window, ss_req in conn.execute(ss_sql):\n        optimize = True\n        dos_periods = periods[prd_idx+n: prd_idx+n+int(dos_window)]\n        ct = int(dos_window)\n        if ct == 0:\n            continue\n        out_flow = lpSum(flow_dict[item][location][to_location][mode][period]\n                            for to_location in flow_dict.get(item, {}).get(location, {})\n                            for mode in flow_dict[item][location][to_location]\n                            for period in flow_dict[item][location][to_location][mode]\n                            if period in dos_periods)/ct + \\\n                    lpSum(demand_dict[item][location][period][''var'']\n                            for period in demand_dict.get(item, {}).get(location, {})\n                            if period in dos_periods)/ct + \\\n                    lpSum(bom_var[item][location][period]\n                            for period in bom_var.get(item, {}).get(location, {})\n                            if period in dos_periods)/ct + \\\n                    lpSum(reg_demand_dict[item][location][period][demand_item]\n                            for period in dos_periods \n                            for demand_item in reg_demand_dict.get(item, {}).get(location, {}).get(period, {}))/ct\n        prob += inventory_dict[item][location][period] + inv_shortfall[item][location][period] \\\n            >= ss_req * out_flow, f''min_ss_constraint_{item}_{location}_{period}''\n    if not optimize:\n        return prob, inv_shortfall\n    prob_objective = prob.objective\n    inv_shortfall_objective = lpSum(inv_shortfall[item][location][period] * product_values[item][location]\n                                for item in inv_shortfall\n                                for location in inv_shortfall[item]\n                                for period in inv_shortfall[item][location])\n    prob.objective = inv_shortfall_objective\n    solver = HiGHS()\n    prob.solve(solver)\n    optimal_value = round(prob.objective.value(),5)\n    update_objective(conn, LpStatus[prob.status], \"Inventory Shortfall Optimization\", optimal_value)\n    if LpStatus[prob.status] == ''Optimal'':\n        if optimal_value <= 0:\n            prob += inv_shortfall_objective <= 0, ''inv_shortfall''\n        else:\n            prob += inv_shortfall_objective <= optimal_value + 1, ''inv_shortfall''\n\n    prob.objective = prob_objective\n    return prob, inv_shortfall\n\ndef minimize_demand_shortfall(conn, prob, shortfall_objective):\n    prob_objective = prob.objective\n    prob.objective = shortfall_objective\n    solver = HiGHS()\n    prob.solve(solver)\n    optimal_val = round(prob.objective.value(),5)\n    update_objective(conn, LpStatus[prob.status], \"Total Demand Shortfall\", optimal_val)\n    if LpStatus[prob.status] == ''Optimal'':\n        if optimal_val <= 0:\n            prob += shortfall_objective <= 0, f\"dem_shortfall\"\n        else:\n            prob += shortfall_objective <= optimal_val + 1, f\"dem_shortfall\"\n    prob.objective = prob_objective\n    return prob\n\ndef minimize_production_shortfall(conn, prob, production_dict):\n    shortfall_dict = {}\n    for item, location, period, min_prod, max_prod in conn.execute(get_production_sql):\n        min_prod = float(min_prod)\n        max_prod = float(max_prod)\n        if min_prod > 0 and min_prod <= max_prod:\n            var = LpVariable(name=f\"prod_shortfall_{item}_{location}_{period}\", lowBound=0, \n                upBound=min_prod, cat=LpContinuous)\n            if item not in shortfall_dict:\n                shortfall_dict[item] = {location: {period: var}}\n            elif location not in shortfall_dict[item]:\n                shortfall_dict[item][location] = {period: var}\n            else:\n                shortfall_dict[item][location][period] = var\n\n            prob += production_dict[item][location][period] + var >= min_prod\n\n    shortfall_var = list(shortfall_dict[item][location][period] \n                           for item in shortfall_dict\n                           for location in shortfall_dict[item]\n                           for period in shortfall_dict[item][location])\n    if len(shortfall_var) == 0:\n        return prob\n    prob_objective = prob.objective\n    prob.objective = lpSum(shortfall_var)\n    solver = HiGHS()\n    prob.solve(solver)\n    update_objective(conn, LpStatus[prob.status], \"Total Production Shortfall\", \n                     round(prob.objective.value(),4))\n    for item in shortfall_dict:\n        for location in shortfall_dict[item]:\n            for period in shortfall_dict[item][location]:\n                var = shortfall_dict[item][location][period]\n                var_val = var.varValue\n                if var_val <= 0:\n                    prob += var == 0\n                else:\n                    print(item, location, period, var_val)\n                    prob += var <= var_val + 0.0001\n\n    prob.objective = prob_objective\n    return prob\n\n\ndef optimize_initial_inventory(conn, prob, initial_inv_objective):\n    prob_objective = prob.objective\n    prob.objective = initial_inv_objective\n    prob.solve()\n    update_objective(conn, LpStatus[prob.status], \"Initial Inventory Optimization\", \n                     round(prob.objective.value(),4))\n    if LpStatus[prob.status] == ''Optimal'':\n        optimal_val = round(prob.objective.value(),5) + 1\n        prob += initial_inv_objective <= optimal_val, f\"initial_inv_shortfall\"\n    prob.objective = prob_objective\n    return prob\n','Active');\nINSERT INTO S_ExecutionFiles VALUES(9,'load_variables.py',NULL,'cl_compute/optimization/load_variables.py','from pulp import LpVariable, LpContinuous, lpSum, LpInteger\nfrom .queries import *\n\ndef generate_demand_var(conn):\n    demand_dict = {}\n    for item, location, period, qty, sp in conn.execute(get_demand_sql):\n        var = LpVariable(name=f\"dem_{item}_{location}_{period}\", lowBound=0, upBound=qty, cat=LpContinuous)\n        if item not in demand_dict:\n            demand_dict[item] = {location: {period: {''var'': var, ''max'': qty, ''sp'': sp}}}\n        elif location not in demand_dict[item]:\n            demand_dict[item][location] = {period: {''var'': var, ''max'': qty, ''sp'': sp}}\n        else:\n            demand_dict[item][location][period] = {''var'': var, ''max'': qty, ''sp'': sp}\n    return demand_dict\n\ndef get_demand_shortfall_var (prob, demand_dict, periods, product_values):\n    new_prd = list(periods)\n    new_prd.reverse()\n    shortfall_var = {}\n    for demand_item in demand_dict:\n        shortfall_var[demand_item] = {}\n        for location in demand_dict[demand_item]:\n            shortfall_var[demand_item][location] = {}\n            for period in demand_dict[demand_item][location]:\n                var = LpVariable(name=f\"shortfall_{demand_item}_{location}_{period}\", \n                                 lowBound=0, upBound=None, cat=LpContinuous)\n                shortfall_var[demand_item][location][period] = var\n                prob += demand_dict[demand_item][location][period][''var''] + \\\n                        var == demand_dict[demand_item][location][period][''max''], \\\n                        f''demand_sat_{demand_item}_{location}_{period}''\n                \n    shortfall_objective = lpSum(shortfall_var[item][location][period] * (new_prd.index(period)+1) *\n                                (product_values[item][location] if product_values[item][location] > 0 else 1)\n                          for item in shortfall_var\n                          for location in shortfall_var[item]\n                          for period in shortfall_var[item][location])\n    return shortfall_var, shortfall_objective\n\ndef generate_flow_var(prob, conn, periods, holding_cost):\n    objective_expr = lpSum(0)\n    flow_dict = {}\n    split_ratio_dict = {}\n    inbound_flow = {}\n    period_len = len(periods)\n    for item, from_location, to_location, mode, period, tpt_cost, \\\n        lead_time, min_qty, max_qty, min_ratio, max_ratio in conn.execute(get_flow_sql):\n        if max_qty == ''INF'':\n            max_qty = None\n        else:\n            max_qty = float(max_qty)\n        var = LpVariable(name=f\"flow_{item}_{from_location}_{to_location}_{mode}_{period}\", \n                         lowBound=min_qty, upBound=max_qty, cat=LpContinuous)\n        if item not in flow_dict:\n            flow_dict[item] = {from_location: {to_location: {mode: {period: var}}}}\n            inbound_flow[item] = {from_location: {to_location: {mode: {period: 0}}}}\n        elif from_location not in flow_dict[item]:\n            flow_dict[item][from_location] = {to_location: {mode: {period: var}}}\n            inbound_flow[item][from_location] = {to_location: {mode: {period: 0}}}\n        elif to_location not in flow_dict[item][from_location]:\n            flow_dict[item][from_location][to_location] = {mode: {period: var}}\n            inbound_flow[item][from_location][to_location] = {mode: {period: 0}}\n        elif mode not in flow_dict[item][from_location][to_location]:\n            flow_dict[item][from_location][to_location][mode] = {period: var}\n            inbound_flow[item][from_location][to_location][mode] = {period: 0}\n        else:\n            flow_dict[item][from_location][to_location][mode][period] = var\n            if period not in inbound_flow[item][from_location][to_location][mode]:\n                inbound_flow[item][from_location][to_location][mode][period] = 0\n        if tpt_cost > 0:\n            objective_expr += tpt_cost * var\n        \n        lead_time_int = int(round(lead_time,0))\n\n        prd_idx = periods.index(period) + lead_time_int\n        if prd_idx < period_len:\n            recv_period = periods[prd_idx]\n            inbound_flow[item][from_location][to_location][mode][recv_period] = var\n        \n        if lead_time_int > 0:\n            objective_expr += holding_cost.get(item, {}).get(to_location, 0) * var * lead_time_int\n\n        if max_ratio == ''INF'':\n            max_ratio = None\n        else:\n            max_ratio = float(max_ratio)\n\n        if min_ratio > 0 or max_ratio is not None:\n            if item not in split_ratio_dict:\n                split_ratio_dict[item] = {from_location: {to_location: {mode: {period: (min_ratio, max_ratio)}}}}\n            elif from_location not in split_ratio_dict[item]:\n                split_ratio_dict[item][from_location] = {to_location: {mode: {period: (min_ratio, max_ratio)}}}\n            elif to_location not in split_ratio_dict[item][from_location]:\n                split_ratio_dict[item][from_location][to_location] = {mode: {period: (min_ratio, max_ratio)}}\n            elif mode not in split_ratio_dict[item][from_location][to_location]:\n                split_ratio_dict[item][from_location][to_location][mode] = {period: (min_ratio, max_ratio)}\n            else:\n                split_ratio_dict[item][from_location][to_location][mode][period] = (min_ratio, max_ratio)\n\n    prob = add_tp_split_ratio_constraint(prob, split_ratio_dict, flow_dict)\n\n    return prob, flow_dict, objective_expr, inbound_flow\n\n\ndef add_tp_split_ratio_constraint(prob, split_ratio_dict, flow_dict):\n    # Mode is considered to be part of split ratio\n    for item in split_ratio_dict:\n        for from_location in split_ratio_dict[item]:\n            for to_location in split_ratio_dict[item][from_location]:\n                for mode in split_ratio_dict[item][from_location][to_location]:\n                    for period in split_ratio_dict[item][from_location][to_location][mode]:\n                        min_ratio, max_ratio = split_ratio_dict[item][from_location][to_location][mode][period]\n                        if min_ratio > 0:\n                            prob += flow_dict[item][from_location][to_location][mode][period] >= min_ratio * \\\n                                    lpSum(flow_dict[item][from_location_x][to_location][mode_x][period]\n                                          for from_location_x in flow_dict[item]\n                                          if to_location in flow_dict[item][from_location_x]\n                                          for mode_x in flow_dict[item][from_location_x][to_location]\n                                          if period in flow_dict[item][from_location_x][to_location][mode_x]), \\\n                                    f\"min_tp_ratio_{item}_{from_location}_{to_location}_{mode}_{period}\"\n                        if max_ratio is not None:\n                            prob += flow_dict[item][from_location][to_location][mode][period] <= max_ratio * \\\n                                    lpSum(flow_dict[item][from_location_x][to_location][mode_x][period]\n                                          for from_location_x in flow_dict[item]\n                                          if to_location in flow_dict[item][from_location_x]\n                                          for mode_x in flow_dict[item][from_location_x][to_location]\n                                          if period in flow_dict[item][from_location_x][to_location][mode_x]), \\\n                                    f\"max_tp_ratio_{item}_{from_location}_{to_location}_{mode}_{period}\"\n    return prob\n\n\ndef generate_inventory_var(conn):\n    objective_expr = lpSum(0)\n    inventory_dict = {}\n    product_values = {}\n    holding_cost_dict = {}\n    for item, location, period, min_inventory, max_inventory, \\\n        holding_cost, product_value in conn.execute(get_inventory_sql):\n        if max_inventory == ''INF'':\n            max_inventory = None\n        else:\n            max_inventory = float(max_inventory)\n        min_inventory = float(min_inventory)\n        if min_inventory == max_inventory:\n            var = min_inventory\n        else:\n            var = LpVariable(name=f\"inv_{item}_{location}_{period}\", lowBound=min_inventory, \n                            upBound=max_inventory, cat=LpContinuous)\n        if item not in inventory_dict:\n            inventory_dict[item] = {location: {period: var}}\n            product_values[item] = {location: product_value}\n            holding_cost_dict[item] = {location: holding_cost}\n        elif location not in inventory_dict[item]:\n            inventory_dict[item][location] = {period: var}\n            product_values[item][location] = product_value\n            holding_cost_dict[item][location] = holding_cost\n        else:\n            inventory_dict[item][location][period] = var\n        objective_expr += var * holding_cost\n\n    return inventory_dict,  objective_expr, product_values, holding_cost_dict\n\n\ndef get_master_data(conn):\n    periods = []\n    for row in conn.execute(get_periods_sql):\n        periods.append(row[0])\n    combinations =[]\n    for item, location in conn.execute(get_combinations_sql):\n        combinations.append((item, location))\n    return periods, combinations\n\n\ndef get_production_var(conn):\n    production_dict = {}\n    for item, location, period, min_prod, max_prod in conn.execute(get_production_sql):\n        if max_prod == ''INF'':\n            max_prod = None\n        else:\n            max_prod = float(max_prod)\n        min_prod = float(min_prod)\n        if max_prod == 0:\n            var = 0\n        else:\n            var = LpVariable(name=f\"production_{item}_{location}_{period}\", lowBound=0, \n                            upBound=max_prod, cat=LpContinuous)\n        if item not in production_dict:\n            production_dict[item] = {location: {period: var}}\n        elif location not in production_dict[item]:\n            production_dict[item][location] = {period: var}\n        else:\n            production_dict[item][location][period] = var\n    return production_dict\n\n\ndef demand_matching(prob, periods, inventory_dict, production_dict, initial_inv, flow_dict, \n                    demand_dict, all_combinations, bom_var, reg_demand_dict, inbound_dict, \n                    expiry_var):\n    for period_no, period in enumerate(periods):\n        for item, location in all_combinations:\n            reg_out = lpSum(reg_demand_dict[item][location][period][demand_item] for \n                           demand_item in reg_demand_dict.get(item, {}).get(location, {}).get(period, {}))\n            demand = demand_dict.get(item, {}).get(location, {}).get(period, {}).get(''var'', 0)\n            reg_in = lpSum(reg_demand_dict[reg_item][location][period][item] \n                           for reg_item in reg_demand_dict\n                           if location in reg_demand_dict.get(reg_item, {})\n                           if period in reg_demand_dict.get(reg_item, {}).get(location, {})\n                           if item in reg_demand_dict.get(reg_item, {}).get(location, {}).get(period, {}))\n            bom_demand = bom_var.get(item, {}).get(location, {}).get(period, 0)\n            outbound_flow = lpSum(flow_dict[item][location][to_location][mode][period]\n                                    for to_location in flow_dict.get(item, {}).get(location, {})\n                                    for mode in flow_dict[item][location][to_location]\n                                    if period in flow_dict[item][location][to_location][mode])\n            inbound_flow = lpSum(inbound_dict[item][from_location][location][mode][period]\n                                    for from_location in inbound_dict.get(item, {})\n                                    if location in inbound_dict[item][from_location]\n                                    for mode in inbound_dict[item][from_location][location]\n                                    if period in inbound_dict[item][from_location][location][mode])\n            expired_qty = lpSum(expiry_var.get(item, {}).get(location, {}).get(period, [0]))\n            beginning_inv = initial_inv.get(item, {}).get(location, {}).get(period, 0)\n            if period_no > 0:\n                beginning_inv += inventory_dict.get(item, {}).get(location, {}).get(periods[period_no-1], 0)\n\n            ending_inv = inventory_dict.get(item, {}).get(location, {}).get(period, 0)\n            production = production_dict.get(item, {}).get(location, {}).get(period, 0)\n\n            prob += inbound_flow + beginning_inv + production + reg_in == \\\n                ending_inv + outbound_flow + demand + bom_demand + reg_out + expired_qty, \\\n                    f''demand_matching_{item}_{location}_{period}''\n    return prob\n\n\ndef get_resource_var(conn):\n    resource_dict = {}\n    for resource, location, period, supply_capacity, min_util, \\\n        max_util in conn.execute(get_resources_sql):\n        if supply_capacity == ''INF'':\n            min_prod = 0\n            max_prod = None\n        elif max_util == ''INF'':\n            min_prod = min_util * float(supply_capacity)\n            max_prod = None\n        else:\n            min_prod = min_util * float(supply_capacity)\n            max_prod = float(max_util) * float(supply_capacity)\n        \n        var = LpVariable(name=f\"res_{resource}_{location}_{period}\", lowBound=min_prod, \n                         upBound=max_prod, cat=LpContinuous)\n        if resource not in resource_dict:\n            resource_dict[resource] = {location: {period: var}}\n        elif location not in resource_dict[resource]:\n            resource_dict[resource][location] = {period: var}\n        else:\n            resource_dict[resource][location][period] = var\n\n    return resource_dict\n\n\n\ndef get_process_var(prob, conn, production_dict):\n    process_dict = {}\n    split_ratio_dict = {}\n    objective_expr = lpSum(0)\n    for item, location, process, period, min_ratio, max_ratio, \\\n        prod_cost in conn.execute(get_processes_sql):\n        var = LpVariable(name=f\"process_{item}_{location}_{process}_{period}\", lowBound=0, \n                         upBound=None, cat=LpContinuous)\n        if item not in process_dict:\n            process_dict[item] = {location: {process: {period: var}}}\n        elif location not in process_dict[item]:\n            process_dict[item][location] = {process: {period: var}}\n        elif process not in process_dict[item][location]:\n            process_dict[item][location][process] = {period: var}\n        else:\n            process_dict[item][location][process][period] = var\n\n        objective_expr += prod_cost * var\n\n        if max_ratio == ''INF'':\n            max_ratio = None\n        else:\n            max_ratio = float(max_ratio)\n\n        if min_ratio > 0 or max_ratio is not None:\n            if item not in split_ratio_dict:\n                split_ratio_dict[item] = {location: {process: {period: (min_ratio, max_ratio)}}}\n            elif location not in split_ratio_dict[item]:\n                split_ratio_dict[item][location] = {process: {period: (min_ratio, max_ratio)}}\n            elif process not in split_ratio_dict[item][location]:\n                split_ratio_dict[item][location][process] = {period: (min_ratio, max_ratio)}\n            else:\n                split_ratio_dict[item][location][process][period] = (min_ratio, max_ratio)\n    prob = add_process_split_ratio_constraint(prob, process_dict, split_ratio_dict)\n\n    for item in production_dict:\n        for location in production_dict[item]:\n            for period in production_dict[item][location]:\n                prob += production_dict[item][location][period] == \\\n                    lpSum(process_dict[item][location][process_x][period] \n                          for process_x in process_dict[item][location]\n                          if period in process_dict[item][location][process_x]), \\\n                            f''process_prod_{item}_{location}_{period}''\n\n    return prob, process_dict, objective_expr\n\n\n\ndef add_process_split_ratio_constraint(prob, process_dict, split_ratio_dict):\n    for item in split_ratio_dict:\n        for location in split_ratio_dict[item]:\n            for process in split_ratio_dict[item][location]:\n                for period in split_ratio_dict[item][location][process]:\n                    min_ratio, max_ratio = split_ratio_dict[item][location][process][period]\n                    if min_ratio > 0:\n                        prob += process_dict[item][location][process][period] >= min_ratio * \\\n                            lpSum(process_dict[item][location][process_x][period] \n                                for process_x in process_dict[item][location]\n                                if period in process_dict[item][location][process_x]), \\\n                                    f''pr_min_const_{item}_{location}_{process}_{period}''\n                    if max_ratio is not None:\n                        prob += process_dict[item][location][process][period] <= max_ratio * \\\n                            lpSum(process_dict[item][location][process_x][period] \n                                for process_x in process_dict[item][location]\n                                if period in process_dict[item][location][process_x]), \\\n                                    f''pr_max_const_{item}_{location}_{process}_{period}''\n    return prob\n\n\n\ndef get_bom_var(prob, conn, process_dict):\n    bom_relation = {}\n    for process, to_item, location, from_item, period, usage_qty, yiel_d in conn.execute(get_bom_sql):\n        if from_item not in bom_relation:\n            bom_relation[from_item] = {location: {period: {process: {to_item: usage_qty / yiel_d}}}}\n        elif location not in bom_relation[from_item]:\n            bom_relation[from_item][location] = {period: {process: {to_item: usage_qty / yiel_d}}}\n        elif period not in bom_relation[from_item][location]:\n            bom_relation[from_item][location][period] = {process: {to_item: usage_qty / yiel_d}}\n        elif process not in bom_relation[from_item][location][period]:\n            bom_relation[from_item][location][period][process] = {to_item: usage_qty / yiel_d}\n        elif to_item not in bom_relation[from_item][location][period][process]:\n            bom_relation[from_item][location][period][process][to_item] = usage_qty / yiel_d\n        else:\n            bom_relation[from_item][location][period][process][to_item] *= 1/yiel_d\n    \n    bom_var = {}\n    for item in bom_relation:\n        bom_var[item] = {}\n        for location in bom_relation[item]:\n            bom_var[item][location] = {}\n            for period in bom_relation[item][location]:\n                var = LpVariable(name=f\"bom_{item}_{location}_{period}\", lowBound=0, \n                         upBound=None, cat=LpContinuous)\n                bom_var[item][location][period] = var\n                prob += bom_var[item][location][period] == \\\n                    lpSum(process_dict.get(to_item,{}).get(location, {}).get(process, {}).get(period, 0) * \\\n                          bom_relation[item][location][period][process][to_item]\n                          for process in bom_relation[item][location][period]\n                          for to_item in bom_relation[item][location][period][process]), \\\n                          f''bom_constraint_{item}_{location}_{period}''\n    return prob, bom_var\n            \n\ndef get_reg_cal_demand(prob, conn, demand_dict):\n    reg_demand_dict = {}\n    for item, location, period, demand_item, qty in conn.execute(reg_demand_sql):\n        if period not in demand_dict.get(demand_item, {}).get(location, {}):\n            continue\n        var = LpVariable(name=f\"reg_dm_{item}_{location}_{period}_{demand_item}\", lowBound=0, \n                        upBound=None, cat=LpContinuous)\n        if item not in reg_demand_dict:\n            reg_demand_dict[item] = {location: {period: {demand_item: var}}}\n        elif location not in reg_demand_dict[item]:\n            reg_demand_dict[item][location] = {period: {demand_item: var}}\n        elif period not in reg_demand_dict[item][location]:\n            reg_demand_dict[item][location][period] = {demand_item: var}\n        else:\n            reg_demand_dict[item][location][period][demand_item] = var\n\n    return prob, reg_demand_dict\n\n            \n\ndef get_initial_inventory(conn, initialize_inv, initial_period):\n    initial_inv = {}\n    objective_expr = lpSum(0)\n    conn.execute(update_entry_date_sql)\n    for item, location, period, initial_qty in conn.execute(initial_inv_sql):\n        if item not in initial_inv:\n            initial_inv[item] = {location: {period: initial_qty}}\n        elif location not in initial_inv[item]:\n            initial_inv[item][location] = {period: initial_qty}\n        else:\n            initial_inv[item][location][period] = initial_qty\n\n    if initialize_inv:\n        for item, location, unit_cost in conn.execute(get_stocking_locations_sql):\n            min_inv = initial_inv.get(item, {}).get(location, {}).get(initial_period, 0)\n            var = LpVariable(name=f\"inv_{item}_{location}\", lowBound=min_inv, \n                             upBound=None, cat=LpContinuous)\n            objective_expr += unit_cost * var\n            if item not in initial_inv:\n                initial_inv[item] = {location: {initial_period: var}}\n            elif location not in initial_inv[item]:\n                initial_inv[item][location]= {initial_period: var}\n            else:\n                initial_inv[item][location][initial_period] = var\n\n    return initial_inv, objective_expr\n\n\ndef get_expiry_variable(conn, prob, periods, flow_dict, demand_dict, bom_var, holding_cost):\n    j = 1\n    expiry_var_dict = {}\n    expiry_holding_cost = lpSum(0)\n    for item, location, entry_period, expiry_period, stock_qty in conn.execute(expiry_inv_sql):\n        expiry_periods = periods[periods.index(entry_period): periods.index(expiry_period)]\n        out_flow = lpSum(flow_dict[item][location][to_location][mode][period]\n                            for to_location in flow_dict.get(item, {}).get(location, {})\n                            for mode in flow_dict[item][location][to_location]\n                            for period in flow_dict[item][location][to_location][mode]\n                            if period in expiry_periods) + \\\n                    lpSum(demand_dict[item][location][period][''var'']\n                            for period in demand_dict.get(item, {}).get(location, {})\n                            if period in expiry_periods) + \\\n                    lpSum(bom_var[item][location][period]\n                            for period in bom_var.get(item, {}).get(location, {})\n                            if period in expiry_periods)\n        \n        expired_var = LpVariable(name=f\"res_{item}_{location}_{expiry_period}_{j}\", \n                                 lowBound=0, upBound=stock_qty, cat=LpContinuous)\n        if item not in expiry_var_dict:\n            expiry_var_dict[item] = {location: {expiry_period: [expired_var]}}\n        elif location not in expiry_var_dict[item]:\n            expiry_var_dict[item][location] = {expiry_period: [expired_var]}\n        elif expiry_period not in expiry_var_dict[item][location]:\n            expiry_var_dict[item][location][expiry_period] = [expired_var]\n        else:\n            expiry_var_dict[item][location][expiry_period].append(expired_var)\n        prob += expired_var + out_flow >= stock_qty, \\\n                    f''expiry_constraint_{item}_{location}_{j}''\n        j = j + 1\n        n = len(periods) - periods.index(expiry_period) + 1\n        expiry_holding_cost += expired_var * n * holding_cost[item][location]\n\n    return prob, expiry_var_dict, expiry_holding_cost','Active');\nINSERT INTO S_ExecutionFiles VALUES(10,'main.py',NULL,'cl_compute/optimization/main.py','from ..sql_connector import insert_log\nfrom ..utilityMethods.populate_periods import main as populate_periods\nfrom .load_variables import *\nfrom .load_constraints import *\nfrom .import_output import main as import_sol\nfrom pulp import LpProblem, LpMinimize, LpStatus, HiGHS\n\ndef main(conn, initialize_inv = False):\n    insert_log(conn, f\"{''-''* 5} LP Initialization Starts {''-''* 5}\")\n    populate_periods(conn)\n    periods, all_combinations = get_master_data(conn)\n    if len(all_combinations) == 0:\n        insert_log(conn, f\"No data for optimization\")\n        return\n    if len(periods) == 0:\n        insert_log(conn, f\"No periods for optimization\")\n        return\n    prob = LpProblem(f\"The_Supply_Planning_Problem\", LpMinimize)\n    conn.execute(\"DELETE FROM O_Objective\")\n    initial_inv, initial_inv_objective = get_initial_inventory(conn, initialize_inv, periods[0])\n    demand_dict = generate_demand_var(conn)\n    inventory_dict,  inv_objective, product_values, holding_cost = generate_inventory_var(conn)\n    demand_shortfall, demand_shortfall_objective = get_demand_shortfall_var(prob, demand_dict, \n                                                                            periods, product_values)\n    prob, flow_dict, tpt_objective, inbound_flow = generate_flow_var(prob, conn, periods, holding_cost)\n    production_dict = get_production_var(conn)\n    prob, process_dict, prod_objective = get_process_var(prob, conn, production_dict)\n    prob, bom_var = get_bom_var(prob, conn, process_dict)\n    resource_dict = get_resource_var(conn)\n    prob = add_resource_constraint(prob, conn, process_dict, resource_dict)\n    prob, reg_demand_dict = get_reg_cal_demand(prob, conn, demand_dict)\n    prob, expiry_var, expiry_holding_cost = get_expiry_variable(conn, prob, periods, flow_dict, \n                                                                demand_dict, bom_var, holding_cost)\n    prob = demand_matching(prob, periods, inventory_dict, production_dict, initial_inv, flow_dict, \n                           demand_dict, all_combinations, bom_var, reg_demand_dict, inbound_flow, \n                           expiry_var)\n    prob = add_min_relase_time_constraint(conn, prob, periods, inventory_dict, flow_dict, demand_dict, \n                                          bom_var, initial_inv, reg_demand_dict)\n    insert_log(conn, f\"{''-''* 5} LP Initialization Completed {''-''* 5}\")\n    prob = minimize_production_shortfall(conn, prob, production_dict)\n    prob = minimize_demand_shortfall(conn, prob, demand_shortfall_objective)\n    if initialize_inv:\n        prob = optimize_initial_inventory(conn, prob, initial_inv_objective)\n    prob, inv_shortfall = minimize_inventory_shortfall(prob, conn, inventory_dict, flow_dict, periods, \n                                            demand_dict, bom_var, product_values, reg_demand_dict)\n    prob.objective = tpt_objective + inv_objective + prod_objective + expiry_holding_cost\n    solver = HiGHS()\n    prob.solve(solver)\n    update_objective(conn, LpStatus[prob.status], \"Total Cost Optimization\", round(prob.objective.value(),4))\n    conn.intermediate_commit()\n    import_sol(conn, demand_dict, inventory_dict, reg_demand_dict, process_dict, \n               flow_dict, inbound_flow, demand_shortfall, inv_shortfall, all_combinations, periods, \n               initial_inv, bom_var, expiry_var)\n','Active');\nINSERT INTO S_ExecutionFiles VALUES(11,'output_queries.py',NULL,'cl_compute/optimization/output_queries.py','\nflow_sql = \"\"\"insert into O_Transportation (ItemId, FromLocationId, ToLocationId,\n                                    StartDate, ModeId, FlowQuantity )\n                 Values (?, ?, ?, ?, ?, ?)\"\"\"\n\nproduction_sql = \"\"\"insert into O_Production (ItemId, LocationId, ProcessId,\n                        StartDate,  ProductionQuantity) Values ( ?, ?, ?, ?, ?)\"\"\"\n\ninventory_sql = \"\"\"insert into O_Inventory (ItemId, LocationId, StartDate,  \n                        OpeningInventory, EndingInventory, ShortFallInventory, InboundStock, OutboundStock,\n                         ProductionQuantity, SatisfiedDemand, Demand, RegistrationInbound, \n                         RegistrationOutbound, ConsumedQuantity, RequiredInventory, IncomingStock, \n                         InTransitInventory, InReleaseInventory, ExpiredQuanity ) \n                        Values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 0, 0, ?)\"\"\"\n\ninitial_inv_sql = \"\"\"insert into O_InitialInventory (ItemId, LocationId, Quantity) \n                        Values (?, ?, ?)\"\"\"\n\nreg_sql = \"\"\"insert into O_ForecastRegistration (ItemId, LocationId, StartDate,  \n                        ForecastItemId, SatisfiedQuantity) \n                        Values (?, ?, ?, ?, ?)\"\"\"\n\nupdate_period_end = \"\"\"UPDATE O_Transportation\n                        set EndDate = date(StartDate, TransportationLeadTime)\n                        FROM \n                        (\n                       select df.rowid as rid,\n                            CASE WHEN dm.TimeFrequency = ''Daily''\n                                    THEN  ''+''||(round(CAST(ifnull(dt.TransportationLeadTime,0) AS FLOAT), 0))|| '' days''\n                                    WHEN dm.TimeFrequency = ''Weekly''\n                                    THEN ''+''||(round(CAST(ifnull(dt.TransportationLeadTime,0) AS FLOAT)/7,0) * 7)|| '' days''\n                                    WHEN dm.TimeFrequency = ''Monthly''\n                                    THEN ''+''||(round(CAST(ifnull(dt.TransportationLeadTime,0) AS FLOAT)/30,0) * 1)|| '' months''\n                                    WHEN dm.TimeFrequency = ''Quarterly''\n                                    THEN ''+''||(round(CAST(ifnull(dt.TransportationLeadTime,0) AS FLOAT)/90,0) * 3)|| '' months''\n                                    WHEN dm.TimeFrequency = ''Yearly''\n                                    THEN ''+''||(round(CAST(ifnull(dt.TransportationLeadTime,0) AS FLOAT)/360,0) * 12)|| '' months''\n                            END as TransportationLeadTime\n                        from O_Transportation df,\n                            I_TransportationPolicy dt,\n                            I_ModelSetup dm\n                        WHERE df.ItemId = dt.ItemId\n                        and   df.FromLocationId = dt.FromLocationId\n                        and   df.ToLocationId = dt.ToLocationId\n                        and   df.ModeId = dt.ModeId\n                        ) t1\n                        WHERE O_Transportation.rowid = t1.rid;\"\"\"\n\n\nupdate_intransit_inventory = \"\"\"UPDATE O_Inventory\n                                Set InTransitInventory = t1.Qty\n                                FROM (\n                                    select  ItemId, \n                                            ToLocationId,\n                                            dp.PeriodStart,\n                                            sum(FlowQuantity) as Qty  \n                                    from O_Transportation df,\n                                         O_Period dp\n                                    WHERE dp.PeriodStart >= df.StartDate\n                                    and   dp.PeriodStart < df.EndDate\n                                    GROUP BY ItemId, \n                                            ToLocationId,\n                                            dp.PeriodStart\n                                ) t1\n                                WHERE O_Inventory.ItemId = t1.ItemId\n                                and   O_Inventory.LocationId = t1.ToLocationId\n                                and   O_Inventory.StartDate = t1.PeriodStart;\"\"\"\n\nupdate_ordered_quantity = \"\"\"UPDATE O_Inventory Set OrderedQuantity = 0;\n                                UPDATE O_Inventory\n                                Set OrderedQuantity = t1.Qty\n                                FROM (\n                                    select  ItemId, \n                                            ToLocationId,\n                                            StartDate,\n                                            sum(FlowQuantity) as Qty  \n                                    from O_Transportation df\n                                    GROUP BY ItemId, \n                                            ToLocationId,\n                                            StartDate\n                                ) t1\n                                WHERE O_Inventory.ItemId = t1.ItemId\n                                and   O_Inventory.LocationId = t1.ToLocationId\n                                and   O_Inventory.StartDate = t1.StartDate\"\"\"\n\nupdate_inrelease_inventory = \"\"\"UPDATE O_Inventory\n                                Set InReleaseInventory = t1.Qty\n                                FROM (\n                                    SELECT  ItemId,\n                                            LocationId,\n                                            dp.PeriodStart as StartDate,\n                                            SUM(ProductionQuantity) as Qty\n                                        from\n                                        (\n                                            SELECT  oi.ItemId,\n                                                    oi.LocationId,\n                                                    oi.StartDate,\n                                                    date(oi.StartDate, ''+''||\n                                                    ROUND(CASE WHEN dm.TimeFrequency = ''Daily''\n                                                    THEN di.MinReleaseTime\n                                                    WHEN dm.TimeFrequency = ''Weekly''\n                                                    THEN round(CAST(di.MinReleaseTime AS FLOAT)/7,4)*7\n                                                    WHEN dm.TimeFrequency = ''Monthly''\n                                                    THEN round(CAST(di.MinReleaseTime AS FLOAT)/30,4)*30\n                                                    WHEN dm.TimeFrequency = ''Quarterly''\n                                                    THEN round(CAST(di.MinReleaseTime AS FLOAT)/90,4)*90\n                                                    WHEN dm.TimeFrequency = ''Yearly''\n                                                    THEN round(CAST(di.MinReleaseTime AS FLOAT)/360,4)*360\n                                                    end, 0)||'' days'') as EndDate,\n                                                    oi.ProductionQuantity\n                                            FROM O_Inventory oi,\n                                                I_InventoryPolicy di,\n                                                I_ModelSetup dm\n                                            WHERE oi.ItemId = di.ItemId\n                                            and   oi.LocationId = di.LocationId\n                                            and   oi.ProductionQuantity > 0\n                                            and   ifnull(di.MinReleaseTime,0) > 0\n                                            ) t1, O_Period dp\n                                            WHERE dp.PeriodStart >= t1.StartDate\n                                            and   dp.PeriodStart < t1.EndDate\n                                            GROUP BY ItemId,\n                                                LocationId,\n                                                dp.PeriodStart\n                                ) t1\n                                WHERE O_Inventory.ItemId = t1.ItemId\n                                and   O_Inventory.LocationId = t1.LocationId\n                                and   O_Inventory.StartDate = t1.StartDate;\"\"\"\n\nupdate_production_cost = \"\"\"UPDATE O_Production\n                            Set ProductionCost = ProductionQuantity * t1.UnitOperationCost\n                            FROM \n                                (\n                                    SELECT ProcessId, ItemId, LocationId, SUM(ifnull(UnitOperationCost,0)) UnitOperationCost\n                                    From I_Processes\n                                    GROUP BY ProcessId, ItemId, LocationId\n                                ) t1\n                            WHERE O_Production.ItemId = t1.ItemId\n                            AND   O_Production.LocationId = t1.LocationId\n                            AND   O_Production.ProcessId = t1.ProcessId\"\"\"\n\nupdate_transportation_cost = \"\"\"UPDATE O_Transportation\n                                set FlowTransportationCost = FlowQuantity * ifnull(I_TransportationPolicy.UnitTransportationCost,0)\n                                FROM I_TransportationPolicy\n                                WHERE O_Transportation.ItemId = I_TransportationPolicy.ItemId\n                                AND   O_Transportation.FromLocationId = I_TransportationPolicy.FromLocationId\n                                AND   O_Transportation.ToLocationId = I_TransportationPolicy.ToLocationId\n                                AND   O_Transportation.ModeId = I_TransportationPolicy.ModeId\"\"\"','Active');\nINSERT INTO S_ExecutionFiles VALUES(12,'queries.py',NULL,'cl_compute/optimization/queries.py','get_demand_sql = \"\"\"select df.ItemId, df.LocationId, dp.PeriodStart, SUM(df.Quantity) as qty, \n                ifnull(max(ifnull(ifnull(df.SalesPrice,di.SalesPrice),dit.salesPrice)),1) as SalesPrice\n                from I_ForecastOrders df,\n                    O_Period dp,\n                    I_InventoryPolicy di,\n                    I_ItemMaster dit\n                WHERE df.ForecastArrivalDate = dp.PeriodStart\n                AND   df.ItemId = di.ItemId\n                AND   df.LocationId = di.LocationId\n                AND   df.ItemId = dit.ItemId\n                GROUP BY di.ItemId, di.LocationId, dp.PeriodStart\"\"\"\n\n\nget_flow_sql = \"\"\"SELECT dt.ItemId, \n                dt.FromLocationId, \n                dt.ToLocationId, \n                dt.ModeId, \n                dp.PeriodStart,\n                ifnull(dt.UnitTransportationCost,0) as UnitTransportationCost,\n                CASE WHEN dm.TimeFrequency = ''Daily''\n                        THEN CAST(ifnull(dt.TransportationLeadTime,0) AS FLOAT)\n                        WHEN dm.TimeFrequency = ''Weekly''\n                        THEN round(CAST(ifnull(dt.TransportationLeadTime,0) AS FLOAT)/7,0)\n                        WHEN dm.TimeFrequency = ''Monthly''\n                        THEN round(CAST(ifnull(dt.TransportationLeadTime,0) AS FLOAT)/30,0)\n                        WHEN dm.TimeFrequency = ''Quarterly''\n                        THEN round(CAST(ifnull(dt.TransportationLeadTime,0) AS FLOAT)/90,0)\n                        WHEN dm.TimeFrequency = ''Yearly''\n                        THEN round(CAST(ifnull(dt.TransportationLeadTime,0) AS FLOAT)/360,0)\n                end as TransportationLeadTime,\n                ifnull(dtp.MinQuantity, ifnull(dt.MinQuantity,0)) MinQuantity,\n                upper(ifnull(dtp.MaxQuantity, ifnull(dt.MaxQuantity, ''INF''))) MaxQuantity,\n                ifnull(dtp.MinSplitRatio, ifnull(dt.MinSplitRatio,0)) MinSplitRatio,\n                upper(ifnull(dtp.MaxSplitRatio, ifnull(dt.MaxSplitRatio, ''INF''))) MaxSplitRatio\n            FROM I_TransportationPolicy dt,\n                 O_Period dp,\n                 I_ModelSetup dm\n            LEFT JOIN I_TransportationPolicyPerPeriod dtp\n            ON    dt.FromLocationId = dtp.FromLocationId\n            AND    dt.ToLocationId = dtp.ToLocationId\n            and    dt.ItemId= dtp.ItemId\n            and    dt.ModeId = dtp.ModeId\n            and    dp.PeriodStart = dtp.StartDate\"\"\"\n\n\nget_inventory_sql = \"\"\"SELECT di.ItemId,\n                            di.LocationId,\n                            dp.PeriodStart,\n                            ifnull(dip.MinEndingInventory, ifnull(di.MinEndingInventory, 0)) as MinEndingInventory,\n                            upper(ifnull(dip.MaxEndingInventory, ifnull(di.MaxEndingInventory, ''INF''))) as MaxEndingInventory,\n                            ifnull(di.InventoryHoldingCost,ifnull(di.InventoryUnitCost, dit.UnitCost) * dm.InterestRate) as holding_cost,\n                            ifnull(di.InventoryUnitCost, dit.UnitCost) as product_value\n                        FROM I_InventoryPolicy di,\n                            O_Period dp,\n                            I_ItemMaster dit,\n                            I_ModelSetup dm\n                        LEFT JOIN I_InventoryPolicyPerPeriod dip\n                        ON di.ItemId = dip.ItemId\n                        AND di.LocationId = dip.LocationId\n                        AND dp.PeriodStart = dip.StartDate\n                        WHERE di.IsStorage = 1\n                        and   di.ItemId = dit.ItemId\"\"\"\n\n\nget_combinations_sql = \"\"\"SELECT ItemId, LocationId\n                        FROM I_InventoryPolicy\"\"\"\n\nget_periods_sql = \"select PeriodStart from O_Period ORDER BY 1\"\n\n\nget_production_sql = \"\"\"SELECT di.ItemId,\n                        di.LocationId,\n                        dp.PeriodStart,\n                        ifnull(dip.MinProductionQuantity, ifnull(di.MinProductionQuantity, 0)) as MinProductionQuantity,\n                        upper(ifnull(dip.MaxProductionQuantity, ifnull(di.MaxProductionQuantity, ''INF''))) as MaxProductionQuantity\n                    FROM I_InventoryPolicy di,\n                        O_Period dp\n                    LEFT JOIN I_InventoryPolicyPerPeriod dip\n                    ON di.ItemId = dip.ItemId\n                    AND di.LocationId = dip.LocationId\n                    AND dp.PeriodStart = dip.StartDate\n                    WHERE di.IsProduction = 1\"\"\"\n\nget_resources_sql = \"\"\"SELECT dr.ResourceId,\n                    dr.LocationId,\n                    dp.PeriodStart,\n                    upper(ifnull(drp.SupplyCapacity, ifnull(dr.SupplyCapacity, ''INF''))) as SupplyCapacity,\n                    ifnull(drp.MinUtilization, ifnull(dr.MinUtilization, ''INF'')) as MinUtilization,\n                    upper(ifnull(drp.MaxUtilization, ifnull(dr.MaxUtilization, ''INF''))) as MaxUtilization\n                FROM I_ResourceMaster dr,\n                    O_Period dp\n                LEFT JOIN I_ResourcePerPeriod drp\n                on dr.ResourceId = drp.ResourceId\n                and dp.PeriodStart = drp.StartDate\"\"\"\n\nget_processes_sql = \"\"\"select   dop.ItemId, \n                            dop.LocationId, \n                            dop.ProcessId,  \n                            dp.PeriodStart,\n                            MAX(ifnull(dpp.MinSplitRatio, ifnull(dop.MinSplitRatio,0))) MinSplitRatio,\n                            MIN(upper(ifnull(dpp.MaxSplitRatio, ifnull(dop.MaxSplitRatio, ''INF'')))) MaxSplitRatio,\n                            SUM(ifnull(dop.UnitOperationCost,0))\n                    from I_Processes dop,\n                        O_Period dp\n                    LEFT JOIN I_ProcessesPerPeriod dpp\n                    ON dop.ItemId = dpp.ItemId\n                    AND dop.LocationId = dpp.LocationId\n                    and dop.ProcessId = dpp.ProcessId\n                    and dop.ProcessStep = dpp.PRocessStep\n                    and dp.PeriodStart = dpp.StartDate\n                    GROUP BY dop.ItemId, \n                             dop.LocationId, \n                             dop.ProcessId,\n                             dp.PeriodStart\"\"\"\n\nget_bom_sql = \"\"\"SELECT         dop.ProcessId,\n                            dop.ItemId AS ToItemId,\n                            dop.LocationId,\n                            db.ItemId AS FromItemId,\n                            dp.PeriodStart,\n                            db.usageQuantity,\n                            ifnull(dpp.yield, ifnull(dop.Yield,1)) AS yield\n            FROM I_Processes dop,\n                I_BOMRecipe db,\n                O_Period dp\n            LEFT JOIN I_ProcessesPerPeriod dpp \n            ON dop.ItemId = dpp.ItemId AND \n            dop.LocationId = dpp.LocationId AND \n            dop.ProcessId = dpp.ProcessId AND \n            dop.ProcessStep = dpp.ProcessStep AND \n            dp.PeriodStart = dpp.StartDate\n            WHERE dop.BOMId = db.BOMId AND \n                dop.LocationId = db.LocationId\"\"\"\n\nget_resource_constraint_sql = \"\"\"SELECT DISTINCT dop.ProcessId,\n                                            dop.ProcessStep,\n                                            dop.ItemId,\n                                            dop.LocationId,\n                                            dp.PeriodStart,\n                                            dop.ResourceId,\n                                            ifnull(dpp.yield, ifnull(dop.Yield,1)) as yield,\n                                            ifnull(ifnull(dpp.UnitOperationTime, dop.UnitOperationTime),0) as UnitOperationTime\n                            FROM I_Processes dop,\n                                O_Period dp\n                            LEFT JOIN I_ProcessesPerPeriod dpp \n                            ON dop.ItemId = dpp.ItemId AND \n                            dop.LocationId = dpp.LocationId AND \n                            dop.ProcessId = dpp.ProcessId AND \n                            dop.ProcessStep = dpp.PRocessStep AND \n                            dp.PeriodStart = dpp.StartDate \"\"\"\n\n\nreg_demand_sql = \"\"\"select dr.ItemId, dr.LocationId, dp.PeriodStart, dr.ForecastItemId, SUM(Quantity) as qty\n                from I_ForecastOrders df,\n                    I_ForecastRegistration dr,\n                    O_Period dp\n                WHERE df.ItemId = dr.ForecastItemId\n                and   df.LocationId = dr.LocationId\n                AND   df.ForecastArrivalDate = dp.PeriodStart\n                and   df.ForecastArrivalDate >= dr.StartDate\n                and   df.ForecastArrivalDate <= dr.EndDate\n                GROUP BY dr.ItemId, dr.LocationId, dp.PeriodStart, dr.ForecastItemId\"\"\"\n\n\nupdate_entry_date_sql = \"\"\"UPDATE I_OpeningStocks\n                        SET EntryDate = I_ModelSetup.StartDate\n                        FROM I_ModelSetup\n                        WHERE IFNULL(EntryDate, I_ModelSetup.StartDate) <= I_ModelSetup.StartDate;\"\"\"\n\ninitial_inv_sql = \"\"\"SELECT ds.ItemId, ds.LocationId, \n                    ifnull(ds.EntryDate, prd.PeriodStart),\n                    ROUND(SUM(ds.Quantity),5) as ttl\n                    FROM I_OpeningStocks ds,\n                        I_InventoryPolicy di,\n                        O_Period dp,\n                        (\n                            select Min(PeriodStart) as PeriodStart, Max(PeriodStart) as PeriodEnd \n                            from O_Period\n                        ) prd\n                    WHERE di.IsStorage = 1\n                    AND   ds.ItemId = di.ItemId\n                    and   ds.LocationId = di.LocationId\n                    and   ifnull(ds.EntryDate, prd.PeriodStart) = dp.PeriodStart\n                    AND   ifnull(ds.ExpiryDate, prd.PeriodEnd) > ifnull(ds.EntryDate, prd.PeriodStart)\n                    GROUP BY ds.ItemId, ds.LocationId, ds.EntryDate\"\"\"\n\nexpiry_inv_sql = \"\"\"SELECT ds.ItemId, ds.LocationId, \n                        ifnull(ds.EntryDate, prd2.PeriodStart) as EntryDate,\n                        prd.PeriodStart as ExpiryDate,\n                    ROUND(SUM(ds.Quantity),5) as ttl\n                    FROM I_OpeningStocks ds,\n                        I_InventoryPolicy di,\n                        O_Period dp,\n                        (\n                            SELECT dp1.PeriodStart, Min(dp2.PeriodStart) as PeriodEnd\n                            FROM O_Period dp1,\n                                 O_Period dp2\n                            WHERE dp2.PEriodStart > dp1.PeriodStart\n                            GROUP BY dp1.PeriodStart\n                        ) prd,\n                        (\n                            select Min(PeriodStart) as PeriodStart, Max(PeriodStart) as PeriodEnd \n                            from O_Period\n                        ) prd2\n                    WHERE di.IsStorage = 1\n                    AND   ds.ItemId = di.ItemId\n                    and   ds.LocationId = di.LocationId\n                    and   ifnull(ds.EntryDate, prd2.PeriodStart) = dp.PeriodStart\n                    AND   ds.ExpiryDate > ifnull(ds.EntryDate, prd2.PeriodStart)\n                    AND   ds.ExpiryDate >= prd.PeriodStart\n                    AND   ds.ExpiryDate < prd.PeriodEnd\n                    AND   ds.ExpiryDate is not null\n                    GROUP BY ds.ItemId, ds.LocationId, ifnull(ds.EntryDate, prd2.PeriodStart), prd.PeriodStart\"\"\"\n\n\nss_sql = \"\"\"select  di.ItemId, \n                    di.LocationId,\n                    dp.PeriodStart,\n                    dp.PeriodIndex,\n                    CASE WHEN TimeFrequency = ''Daily''\n                    THEN di.DOSWindow\n                    WHEN TimeFrequency = ''Weekly''\n                    THEN round(di.DOSWindow/7,0)\n                    WHEN TimeFrequency = ''Monthly''\n                    THEN round(di.DOSWindow/30,0)\n                    WHEN TimeFrequency = ''Quarterly''\n                    THEN round(di.DOSWindow/90,0)\n                    WHEN TimeFrequency = ''Yearly''\n                    THEN round(di.DOSWindow/360,0)\n                    end as DOSWindow,\n                    CASE WHEN TimeFrequency = ''Daily''\n                    THEN ifnull(dip.SafetyStockDOS,di.SafetyStockDOS)\n                    WHEN TimeFrequency = ''Weekly''\n                    THEN round(CAST(ifnull(dip.SafetyStockDOS,di.SafetyStockDOS) AS FLOAT)/7,4)\n                    WHEN TimeFrequency = ''Monthly''\n                    THEN round(CAST(ifnull(dip.SafetyStockDOS,di.SafetyStockDOS) AS FLOAT)/30,4)\n                    WHEN TimeFrequency = ''Quarterly''\n                    THEN round(CAST(ifnull(dip.SafetyStockDOS,di.SafetyStockDOS) AS FLOAT)/90,4)\n                    WHEN TimeFrequency = ''Yearly''\n                    THEN round(CAST(ifnull(dip.SafetyStockDOS,di.SafetyStockDOS) AS FLOAT)/360,4)\n                    end as SafetyStockDOS\n            from I_InventoryPolicy di,\n                 I_ModelSetup dm,\n                 (    select PeriodStart, row_number() over (order by PeriodStart) - 1 as PeriodIndex\n                      from O_Period\n                 ) dp\n            LEFT JOIN I_InventoryPolicyPerPeriod dip\n            ON di.ItemId = dip.ItemId\n            AND di.LocationId = dip.LocationId\n            AND dp.PeriodStart = dip.StartDate\n            WHERE di.IsStorage = 1\n            AND   ifnull(dip.SafetyStockDOS, ifnull(di.SafetyStockDOS, 0)) > 0\"\"\"\n\n\nregistration_ss = \"\"\"SELECT di2.ItemId,\n                        di2.LocationId,\n                        dp.PeriodStart,\n                        CASE WHEN TimeFrequency = ''Daily''\n                                THEN di1.DOSWindow\n                                WHEN TimeFrequency = ''Weekly''\n                                THEN round(di1.DOSWindow/7,0)\n                                WHEN TimeFrequency = ''Monthly''\n                                THEN round(di1.DOSWindow/30,0)\n                                WHEN TimeFrequency = ''Quarterly''\n                                THEN round(di1.DOSWindow/90,0)\n                                WHEN TimeFrequency = ''Yearly''\n                                THEN round(di1.DOSWindow/360,0)\n                        end as DOSWindow,\n                        max(CASE WHEN TimeFrequency = ''Daily''\n                            THEN di1.SafetyStockDOS\n                            WHEN TimeFrequency = ''Weekly''\n                            THEN round(CAST(di1.SafetyStockDOS AS FLOAT)/7,4)\n                            WHEN TimeFrequency = ''Monthly''\n                            THEN round(CAST(di1.SafetyStockDOS AS FLOAT)/30,4)\n                            WHEN TimeFrequency = ''Quarterly''\n                            THEN round(CAST(di1.SafetyStockDOS AS FLOAT)/90,4)\n                            WHEN TimeFrequency = ''Yearly''\n                            THEN round(CAST(di1.SafetyStockDOS AS FLOAT)/360,4)\n                            end) as SafetyStockDOS\n                    FROM I_ForecastRegistration dr,\n                        I_InventoryPolicy di1,\n                        I_InventoryPolicy di2,\n                        O_Period dp,\n                        I_ModelSetup dm\n                    WHERE 1 = 1\n                    and   dr.ForecastItemId = di1.ItemId\n                    and   dr.LocationId = di1.LocationId\n                    and   dr.ItemId = di2.ItemId\n                    and   dr.LocationId = di2.LocationId\n                    AND   di1.IsStorage = 1\n                    and   dp.PeriodStart >= dr.StartDate\n                    and   dp.PeriodStart <= dr.EndDate\n                    GROUP BY di2.ItemId,\n                            di2.LocationId,\n                            dp.PeriodStart\"\"\"\n\n\nmin_release_sql = \"\"\"SELECT di.ItemId,\n                            di.LocationId,\n                            dp.PeriodStart,\n                            dp.PeriodIndex,\n                            CASE WHEN dm.TimeFrequency = ''Daily''\n                                THEN di.MinReleaseTime\n                                WHEN dm.TimeFrequency = ''Weekly''\n                                THEN round(CAST(di.MinReleaseTime AS FLOAT)/7,4)\n                                WHEN dm.TimeFrequency = ''Monthly''\n                                THEN round(CAST(di.MinReleaseTime AS FLOAT)/30,4)\n                                WHEN dm.TimeFrequency = ''Quarterly''\n                                THEN round(CAST(di.MinReleaseTime AS FLOAT)/90,4)\n                                WHEN dm.TimeFrequency = ''Yearly''\n                                THEN round(CAST(di.MinReleaseTime AS FLOAT)/360,4)\n                                end as MinReleaseTime\n                        FROM I_InventoryPolicy di,\n                            I_ModelSetup dm,\n                            (    select PeriodStart, row_number() over (order by PeriodStart) - 1 as PeriodIndex\n                                            from O_Period\n                            ) dp\n                        WHERE di.IsStorage = 1\n                        AND  ifnull(di.MinReleaseTime, 0) > 0\"\"\"\n\nget_stocking_locations_sql = \"\"\"select I_ItemMaster.ItemId, LocationId, \n                                    ifnull(Max(InventoryUnitCost), I_ItemMaster.UnitCost) as UnitCostModel\n                                from I_InventoryPolicy, I_ItemMaster\n                                WHERE IsStorage = 1\n                                and   I_ItemMaster.ItemId = I_InventoryPolicy.ItemId\n                                GROUP BY I_ItemMaster.ItemId, LocationId\"\"\"','Active');\nINSERT INTO S_ExecutionFiles VALUES(13,'backup_and_restore.py',NULL,'cl_compute/utilityMethods/backup_and_restore.py','from ..sql_connector import insert_log\n\ndef backup_tables(conn):\n    '''''' Few tables are populated with default values for model validation, so backup of such tables is taken \n        which will then be restored after model validation ''''''\n    conn.execute(\"DROP TABLE IF EXISTS XT_InventoryPolicy\")\n    conn.execute(\"DROP TABLE IF EXISTS XT_ForecastOrders\")\n    conn.execute(\"DROP TABLE IF EXISTS XT_Processes\")\n    conn.execute(\"DROP TABLE IF EXISTS XT_TransportationPolicy\")\n    conn.execute(\"CREATE TABLE XT_InventoryPolicy as SELECT * FROM I_InventoryPolicy\")\n    conn.execute(\"CREATE TABLE XT_ForecastOrders as SELECT * FROM I_ForecastOrders\")\n    conn.execute(\"CREATE TABLE XT_TransportationPolicy as SELECT * FROM I_TransportationPolicy\")\n    conn.execute(\"CREATE TABLE XT_Processes as SELECT * FROM I_Processes\")\n    insert_log(conn, f\"{''-''* 5} Table backup completed {''-''* 5}\")\n\ndef restore_tables(conn):\n    conn.execute(\"DELETE FROM I_InventoryPolicy\")\n    conn.execute(\"INSERT INTO I_InventoryPolicy SELECT * FROM XT_InventoryPolicy\")\n    conn.execute(\"DELETE FROM I_ForecastOrders\")\n    conn.execute(\"INSERT INTO I_ForecastOrders SELECT * FROM XT_ForecastOrders\")\n    conn.execute(\"DELETE FROM I_Processes\")\n    conn.execute(\"INSERT INTO I_Processes SELECT * FROM XT_Processes\")\n    conn.execute(\"DELETE FROM I_TransportationPolicy\")\n    conn.execute(\"INSERT INTO I_TransportationPolicy SELECT * FROM XT_TransportationPolicy\")\n    conn.execute(\"DROP TABLE XT_InventoryPolicy\")\n    conn.execute(\"DROP TABLE XT_ForecastOrders\")\n    conn.execute(\"DROP TABLE XT_Processes\")\n    conn.execute(\"DROP TABLE XT_TransportationPolicy\")\n    insert_log(conn, f\"{''-''* 5} Table restore completed {''-''* 5}\")\n','Active');\nINSERT INTO S_ExecutionFiles VALUES(14,'clean_model.py',NULL,'cl_compute/utilityMethods/clean_model.py','from .populate_periods import main as populate_periods\nfrom .validation_queries import primary_keys\nfrom .populate_defaults import update_defaults\nfrom ..sql_connector import insert_log\n\ndef round_decimals(conn, round_decimals = 6):\n    '''''' This method would round all numeric fields to 6 decimals from I_% tables''''''\n    get_table_sql = \"\"\"select tbl_name from sqlite_schema\n                        where type = ''table''\n                        and substr(tbl_name, 1,2) = ''I_''\"\"\"\n    table_names = conn.execute(get_table_sql).fetchall()\n\n    for table_name in table_names:\n        get_col_sql = \"select name from pragma_table_info(?) WHERE type = ''NUMERIC''\"\n        col_names = conn.execute(get_col_sql, table_name).fetchall()\n        for col_name in col_names:\n            c_name = col_name[0]\n            t_name = table_name[0]\n            update_query = f\"\"\"UPDATE [{t_name}]\n                                SET [{c_name}] = round([{c_name}], {round_decimals})\n                                WHERE instr(CAST([{c_name}] as STRING), ''.'') > 0\n                                and   length(CAST([{c_name}] as STRING)) - \n                                   instr(CAST([{c_name}] as STRING), ''.'') > {round_decimals}\n                                and   round([{c_name}], {round_decimals}) != 0\"\"\"\n            conn.execute(update_query)\n\nupdate_stock_entry_date = \"\"\"UPDATE I_OpeningStocks\n                SET EntryDate = I_ModelSetup.StartDate\n                FROM I_ModelSetup\n                WHERE IFNULL(EntryDate, I_ModelSetup.StartDate) <= I_ModelSetup.StartDate\"\"\"\n\nupdate_registration_dates = \"\"\"UPDATE I_ForecastRegistration\n                                SET StartDate = I_ModelSetup.StartDate\n                                FROM I_ModelSetup\n                                WHERE IFNULL(I_ForecastRegistration.StartDate, I_ModelSetup.StartDate) <= I_ModelSetup.StartDate ;\n                                UPDATE I_ForecastRegistration\n                                SET EndDate = t1.PeriodEndDate\n                                FROM (\n                                select Max(PeriodStart) as PeriodEndDate FROM O_Period\n                                ) t1\n                                WHERE IFNULL(I_ForecastRegistration.EndDate, t1.PeriodEndDate) >= t1.PeriodEndDate;\"\"\"\n\nbom_select_query = \"\"\"select distinct dob.ItemId, dob.LocationId\n                        from TEMP.ActiveCombinations ac,\n                            I_InventoryPolicy di,\n                            I_Processes dop,\n                            I_BOMRecipe dob\n                        LEFT JOIN \n                            TEMP.ActiveCombinations ac2 ON dob.ItemId = ac2.ItemId AND     \n                            dob.LocationId = ac2.LocationId\n                        WHERE ac.ItemId = di.ItemId\n                        AND   ac.LocationId = di.LocationId\n                        and   di.IsProduction = 1\n                        AND   di.ItemId = dop.ItemId\n                        and   di.LocationId = dop.LocationId\n                        and   dop.BOMId = dob.BOMId\n                        and   dop.LocationId = dob.LocationId\n                        AND   dob.UsageQuantity > 0\n                        AND   ac2.ItemId is null\"\"\"\n\ndef main(conn):\n    insert_log(conn, f\"{''-''* 5} Model Clean Started {''-''* 5}\")\n    delete_null_primary_keys(conn)\n    create_combinations(conn)\n    delete_inactives(conn)\n    conn.execute(update_stock_entry_date)\n    conn.execute(update_registration_dates)\n    round_decimals(conn)\n    update_defaults(conn)\n    insert_log(conn, f\"{''-''* 5} Model Clean Completed {''-''* 5}\")\n\ndef create_combinations(conn):\n    ''''''This method creates all item location combinations (which have any dependency on demand)\n       in TEMP.ActiveCombinations table, so that any other item/location can be deleted later in \n       delete_inactives method''''''\n\n    populate_periods(conn) #populate periods in O_Period table based on model horizon\n    delete_zero_forecast =   \"\"\"DELETE from I_ForecastOrders\n                                WHERE Quantity <= 0\"\"\"\n    conn.execute(delete_zero_forecast)\n    delete_forecast = \"\"\"DELETE from I_ForecastOrders\n                         WHERE ForecastArrivalDate not in (SELECT PeriodStart From O_Period)\"\"\"\n    conn.execute(delete_forecast)\n\n    conn.execute(\"DROP TABLE IF EXISTS TEMP.ActiveCombinations\")\n    #insert item location combinations based on forecast and registration calendar (item_id, location_id)\n    query = \"\"\" CREATE TABLE TEMP.ActiveCombinations\n                AS\n                SELECT DISTINCT ifnull(I_ForecastRegistration.ItemId, I_ForecastOrders.ItemId) AS ItemId,\n                                I_ForecastOrders.LocationId\n                FROM I_ForecastOrders\n                    LEFT JOIN\n            I_ForecastRegistration ON I_ForecastOrders.ItemId = I_ForecastRegistration.ForecastItemId AND \n                                        I_ForecastOrders.LocationId = I_ForecastRegistration.LocationId AND \n                                        I_ForecastOrders.ForecastArrivalDate >= I_ForecastRegistration.StartDate AND \n                                        I_ForecastOrders.ForecastArrivalDate <= I_ForecastRegistration.EndDate\n                WHERE I_ForecastOrders.Quantity > 0\"\"\"\n    conn.execute(query)\n\n    # insert combination from forecast which are not in active combinations\n    query = \"\"\"INSERT INTO TEMP.ActiveCombinations (ItemId, LocationId)\n                select distinct df.ItemId, df.LocationId\n                from I_ForecastOrders df\n                LEFT JOIN TEMP.ActiveCombinations ac\n                ON df.ItemId = ac.ItemId\n                and df.LocationId = ac.LocationId\n                WHERE df.Quantity > 0\n                and   ac.ItemId is null\"\"\"\n    conn.execute(query)\n\n    #insert upstream item, location in TEMP.ActiveCombinations table based on upstream transportation\n    propogate_distribution(conn)\n    ct = 1\n    while ct > 0:\n        row = conn.execute(bom_select_query).fetchone()\n        if row:\n            #insert upstream item, location in TEMP.ActiveCombinations table based on bills of materials\n            propogate_BOM(conn)\n            #insert upstream item, location in TEMP.ActiveCombinations table based on transportation policy\n            propogate_distribution(conn)\n        else:\n            ct = 0\n\n\ndef propogate_distribution(conn):\n    ''''''This method inserts item location combination in TEMP.ActiveCombinations table based on upstream \n        transportation policy of existing combinations in TEMP.ActiveCombinations table''''''\n    ct = 1\n    while ct > 0:\n        conn.intermediate_commit()\n        #insert ItemId, FromLocation based on transportation policy\n        add_query = \"\"\" INSERT INTO TEMP.ActiveCombinations (ItemId, LocationId)\n                        SELECT DISTINCT dt.ItemId,\n                                        dt.FromLocationId\n                        FROM TEMP.ActiveCombinations ac,\n                            I_TransportationPolicy dt\n                            LEFT JOIN\n                            TEMP.ActiveCombinations ac2 ON dt.ItemId = ac2.ItemId AND \n                                                        dt.FromLocationId = ac2.LocationId\n                        WHERE ac.ItemId = dt.ItemId AND \n                            ac.LocationId = dt.ToLocationId AND \n                            ac2.ItemId IS NULL\"\"\"\n        conn.execute(add_query)\n        ct = conn.execute(\"select changes()\").fetchone()[0]\n\ndef propogate_BOM(conn):\n    ''''''This method inserts item location combination in TEMP.ActiveCombinations table based on upstream \n        bill of materials of existing combinations in TEMP.ActiveCombinations table''''''\n    ct = 1\n    while ct > 0:\n        conn.intermediate_commit()\n        #insert InputItemId, Location based on bills of materials\n        add_query = f\"\"\"INSERT INTO TEMP.ActiveCombinations (ItemId, LocationId)\n                         {bom_select_query} \"\"\"\n\n        conn.execute(add_query)\n        ct = conn.execute(\"select changes()\").fetchone()[0]\n\ndef delete_inactives(conn):\n    ''''''This method deletes all item/locations which doesn''t exist in TEMP.ActiveCombinations table\n        It then deletes all inactive resource and bill of materials\n        It then deletes all records where period lies out of model horizon''''''\n    table_names = [\"I_BOMRecipe\", \"I_InventoryPolicy\", \"I_ForecastOrders\", \n                    \"I_InventoryPolicyPerPeriod\", \"I_Processes\", \"I_ProcessesPerPeriod\",\n                    \"I_ForecastRegistration\", \"I_OpeningStocks\" ]\n\n    # We will now delete all other combinations from different tables except records in TEMP.ActiveCombinations table,\n    for table_name in table_names:\n        delete_query = f\"\"\"DELETE FROM {table_name}\n                        WHERE rowid in \n                        (\n                        select dbi.rowid\n                        from {table_name} dbi\n                        LEFT JOIN TEMP.ActiveCombinations sc\n                        ON dbi.ItemId = sc.ItemId\n                        and dbi.LocationId = sc.LocationId\n                        WHERE sc.ItemId is null\n                        )\"\"\"\n        conn.execute(delete_query)\n\n    # Delete items except records in TEMP.ActiveCombinations table\n    delete_item = \"\"\"DELETE FROM I_ItemMaster\n                    WHERE ItemId NOT IN (\n                    SELECT DISTINCT ItemId\n                    FROM TEMP.ActiveCombinations\n                            )\"\"\"    \n    conn.execute(delete_item)\n\n\n    delete_locations = \"\"\"DELETE FROM I_LocationMaster\n                            WHERE LocationId NOT IN (\n                            SELECT DISTINCT LocationId\n                            FROM TEMP.ActiveCombinations\n                        )\"\"\"\n    conn.execute(delete_locations)\n\n    delete_registration_calendar = \"\"\"DELETE FROM I_ForecastRegistration\n                                        WHERE rowid in \n                                        (\n                                        select dbi.rowid\n                                        from I_ForecastRegistration dbi\n                                        LEFT JOIN TEMP.ActiveCombinations sc\n                                        ON dbi.ForecastItemId = sc.ItemId\n                                        and dbi.LocationId = sc.LocationId\n                                        WHERE sc.ItemId is null  )\"\"\"\n    conn.execute(delete_registration_calendar)\n\n    delete_registration_calendar = \"\"\"DELETE FROM I_ForecastRegistration\n                                        WHERE rowid in\n                                        (\n                                            SELECT dr.rowid\n                                            FROM I_ForecastRegistration dr,\n                                                    ( select min(periodStart) as min_period, max(periodStart) as max_period\n                                                        FROM O_Period\n                                                    ) t2\n                                            WHERE dr.StartDate > t2.max_period\n                                            OR    dr.EndDate < t2.min_period\n                                        )\"\"\"\n    conn.execute(delete_registration_calendar)\n\n    delete_resource = \"\"\"DELETE FROM I_ResourceMaster\n                            WHERE rowid IN (\n                            SELECT dbi.rowid\n                            FROM I_ResourceMaster dbi\n                                LEFT JOIN\n                                I_Processes sc ON dbi.ResourceId = sc.ResourceId AND \n                                                            dbi.LocationId = sc.LocationId\n                            WHERE sc.ItemId IS NULL\n                        )\"\"\"\n    conn.execute(delete_resource)\n\n    delete_bom = \"\"\"DELETE FROM I_BOMRecipe\n                            WHERE rowid IN (\n                            SELECT dbi.rowid\n                            FROM I_BOMRecipe dbi\n                                LEFT JOIN\n                                I_Processes sc ON dbi.BOMId = sc.BOMId AND \n                                                            dbi.LocationId = sc.LocationId\n                            WHERE sc.ItemId IS NULL\n                        )\"\"\"\n    conn.execute(delete_bom)\n\n    delete_redundant_bom = \"\"\"DELETE FROM I_BOMRecipe\n                              WHERE UsageQuantity = 0\"\"\"\n    conn.execute(delete_redundant_bom)\n\n    delete_resource_period = \"\"\"DELETE from I_ResourcePerPeriod\n                                    WHERE ResourceId NOT IN\n                                        (SELECT DISTINCT ResourceId FROM I_ResourceMaster)\"\"\"\n    conn.execute(delete_resource_period)\n\n    dt_dict = {''I_TransportationPolicy'': [''FromLocationId'', ''ToLocationId''],\n                ''I_TransportationPolicyPerPeriod'': [''FromLocationId'', ''ToLocationId'']}\n    \n    for table_name in dt_dict:\n        for location_column in dt_dict[table_name]:\n            delete_query = f\"\"\"DELETE FROM {table_name}\n                        WHERE rowid in \n                        (\n                        select dbi.rowid\n                        from {table_name} dbi\n                        LEFT JOIN TEMP.ActiveCombinations sc\n                        ON dbi.ItemId = sc.ItemId\n                        and dbi.{location_column} = sc.LocationId\n                        WHERE sc.ItemId is null\n                        )\"\"\"\n            conn.execute(delete_query)\n\n    periodic_tables = [''I_ProcessesPerPeriod'', ''I_ResourcePerPeriod'',''I_TransportationPolicyPerPeriod'']\n\n    for table_name in periodic_tables:\n        delete_query = f\"\"\"DELETE from {table_name}\n                           WHERE StartDate not in ( select PeriodStart from O_Period)\"\"\"\n        conn.execute(delete_query)\n    \n    update_null_bom = \"\"\"UPDATE I_Processes\n                            SET BOMId = null\n                            WHERE rowid in\n                            (\n                            SELECT rowid\n                            FROM I_Processes \n                            WHERE BOMId is not null\n                            AND   BOMId not in (SELECT BOMId FROM I_BOMRecipe)\n                            )\"\"\"\n    conn.execute(update_null_bom)\n\n\n\ndef delete_null_primary_keys(conn):\n    for table_name in primary_keys:\n        for col_name in primary_keys[table_name]:\n            query = f\"\"\"DELETE FROM [{table_name}]\n                        WHERE [{col_name}] is null\"\"\"\n            conn.execute(query)\n\n\n','Active');\nINSERT INTO S_ExecutionFiles VALUES(15,'populate_defaults.py',NULL,'cl_compute/utilityMethods/populate_defaults.py','from ..sql_connector import insert_log\n\nupdate_inventory_sp = \"\"\"UPDATE I_InventoryPolicy\n                        set SalesPrice = I_ItemMaster.SalesPrice\n                        FROM I_ItemMaster\n                        WHERE I_InventoryPolicy.ItemId = I_ItemMaster.ItemId\n                        and   I_ItemMaster.SalesPrice IS NOT NULL\n                        AND   I_InventoryPolicy.SalesPrice IS NULL\"\"\"\n\nupdate_inventory_cost = \"\"\"UPDATE I_InventoryPolicy\n                        set InventoryUnitCost = I_ItemMaster.UnitCost\n                        FROM I_ItemMaster\n                        WHERE I_InventoryPolicy.ItemId = I_ItemMaster.ItemId\n                        and   I_ItemMaster.UnitCost IS NOT NULL\n                        AND   I_InventoryPolicy.InventoryUnitCost IS NULL\"\"\"\n\nupdate_forecast_sp = \"\"\"UPDATE I_ForecastOrders\n                        set SalesPrice = I_InventoryPolicy.SalesPrice\n                        FROM I_InventoryPolicy\n                        WHERE I_ForecastOrders.ItemId = I_InventoryPolicy.ItemId\n                        AND   I_ForecastOrders.LocationId = I_InventoryPolicy.LocationId\n                        AND   I_InventoryPolicy.SalesPrice IS NOT NULL\n                        AND   I_ForecastOrders.SalesPrice IS NULL\"\"\"\n\ndefault_data = {''I_InventoryPolicy'': {\n                                ''MinEndingInventory'': 0,\n                                ''MaxEndingInventory'': ''INF'',\n                                ''MinProductionQuantity'': 0,\n                                ''MaxProductionQuantity'': ''INF'',\n                                ''SafetyStockDOS'': 0,\n                                ''DOSWindow'': 0,\n                                ''InventoryStatus'': 1\n                                },\n                ''I_ItemMaster'':   {\n                                ''ItemStatus'': 1\n                                },\n                ''I_Processes'': {\n                                ''Yield'': 1\n                                },\n                ''I_ResourceMaster'': {\n                                ''SupplyCapacity'': ''INF'',\n                                ''MinUtilization'': 0,\n                                ''MaxUtilization'': 1\n                                }\n                            }\n\ndef update_defaults(conn):\n    '''''' populate default values based on default_data object \n        1. It populates UnicostModel in I_InventoryPolicy table if there are nulls and \n            there is corresponding not null record in I_ItemMaster table\n        2. It populates SalesPrice column in I_InventoryPolicy table, if there are nulls and there is corresponding\n            not null record in I_ItemMaster table\n        3. It populates SalesPrice column in I_ForecastOrders table, if there are nulls and \n            there is corresponding not null record in I_InventoryPolicy table\n    ''''''\n    for table_name in default_data:\n        for column_name in default_data[table_name]:\n            default_value = (default_data[table_name][column_name],)\n            query = f\"\"\"UPDATE [{table_name}]\n                        SET [{column_name}] = ?\n                        WHERE [{column_name}] IS NULL\"\"\"\n            conn.execute(query, default_value)\n    conn.execute(update_inventory_cost)\n    conn.execute(update_inventory_sp)\n    conn.execute(update_forecast_sp)\n    insert_log(conn, f\"{''-''* 5} Populate default completed {''-''* 5}\")','Active');\nINSERT INTO S_ExecutionFiles VALUES(16,'populate_periods.py',NULL,'cl_compute/utilityMethods/populate_periods.py','from ..sql_connector import insert_log\n\ndef main(conn):\n    ''''''Populate periods in O_Period table based on I_ModelSetup table ''''''\n    conn.execute(\"DELETE FROM O_Period\")\n    query = \"\"\"INSERT INTO O_Period (PeriodIdx, PeriodStart, PeriodEnd)\n                    with recursive cnt(x)\n                    AS\n                        ( \n                        Values(0)\n                        UNION ALL\n                        select x + 1\n                        from cnt,\n                            I_ModelSetup\n                        where x < I_ModelSetup.NumberOfPeriods - 1\n                        )\n                    select x, CASE WHEN TimeFrequency = ''Daily''\n                        THEN date(I_ModelSetup.StartDate, ''+''||x||'' days'')\n                        WHEN TimeFrequency = ''Weekly''\n                        THEN date(I_ModelSetup.StartDate, ''+''||x * 7||'' days'')\n                        WHEN TimeFrequency = ''Monthly''\n                        THEN date(I_ModelSetup.StartDate, ''+''||x||'' months'')\n                        WHEN TimeFrequency = ''Quarterly''\n                        THEN date(I_ModelSetup.StartDate, ''+''||x * 3||'' months'')\n                        WHEN TimeFrequency = ''Yearly''\n                        THEN date(I_ModelSetup.StartDate, ''+''||x * 12||'' months'')\n                        end as periodStartDate,\n                        CASE WHEN TimeFrequency = ''Daily''\n                        THEN date(I_ModelSetup.StartDate, ''+''||x+1||'' days'')\n                        WHEN TimeFrequency = ''Weekly''\n                        THEN date(I_ModelSetup.StartDate, ''+''||(x+1) * 7||'' days'')\n                        WHEN TimeFrequency = ''Monthly''\n                        THEN date(I_ModelSetup.StartDate, ''+''||(x+1)||'' months'')\n                        WHEN TimeFrequency = ''Quarterly''\n                        THEN date(I_ModelSetup.StartDate, ''+''||(x+1) * 3||'' months'')\n                        WHEN TimeFrequency = ''Yearly''\n                        THEN date(I_ModelSetup.StartDate, ''+''||(x+1) * 12||'' months'')\n                        end as periodEndDate\n                    from cnt, I_ModelSetup\"\"\"\n    conn.execute(query)\n    update_query = \"\"\"UPDATE O_Period\n                        set PeriodDays = julianday(PeriodEnd) - julianday(PeriodStart),\n                            PeriodYear = substr(PeriodStart,1,4),\n                            PeriodMonth = substr(PeriodStart,1,7),\n                            PeriodQuarter = substr(PeriodStart,1,4) || ''_'' ||\n                                            CASE WHEN  substr(PeriodStart,6,2) IN (''01'', ''02'', ''03'') THEN ''Q1''\n                                            WHEN substr(PeriodStart,6,2) IN (''04'', ''05'', ''06'') THEN ''Q2''\n                                            WHEN substr(PeriodStart,6,2) IN (''07'', ''08'', ''09'') THEN ''Q3''\n                                            WHEN substr(PeriodStart,6,2) IN (''10'', ''11'', ''12'') THEN ''Q4''\n                                            END\"\"\"\n    conn.execute(update_query)\n    conn.intermediate_commit()','Active');\nINSERT INTO S_ExecutionFiles VALUES(17,'propogate_demand.py',NULL,'cl_compute/utilityMethods/propogate_demand.py','from ..sql_connector import insert_log\nfrom .populate_periods import main as populate_periods\n\nbom_select_query = \"\"\"SELECT t2.FromItemId, t2.ToItemId, t2.LocationId, \n                                sum(t2.usageQuantity * da.Quantity) as Quantity\n                                FROM\n                                (\n                                SELECT t1.ItemId as ToItemId, t1.LocationId, \n                                db.ItemId as FromItemId, usageQuantity\n                                FROM\n                                (\n                                    select  dop.ItemId, \n                                            dop.LocationId, \n                                            dop.BOMId,\n                                            min(dop.rowid) as rid\n                                    from I_Processes dop,\n                                        I_InventoryPolicy di\n                                    WHERE dop.BOMId is not null\n                                    AND   di.ItemId = dop.ItemId\n                                    and   di.LocationId = dop.LocationId\n                                    GROUP BY dop.ItemId, dop.LocationId\n                                ) as t1,\n                                (\n                                    select db.*\n                                    from I_BOMRecipe db,\n                                        I_InventoryPolicy di\n                                    WHERE di.ItemId = db.ItemId\n                                    and   di.LocationId = db.LocationId\n                                ) db\n                                WHERE t1.LocationId = db.LocationId\n                                AND   t1.BOMId = db.BOMId\n                                ) T2,\n                                    O_DemandAnalysis da\n                                WHERE t2.ToItemId = da.ItemId\n                                and   t2.LocationId = da.LocationId\n                                and   da.FulFilledQuantity = 0\n                                GROUP BY t2.FromItemId, t2.ToItemId, t2.LocationId \"\"\"\n\ndef main(conn):\n    ''''''This method only works if there is only one sourcing option for each inventory''''''\n    '''''' This method will first add demand based on D_ForecastOrderItem table and then add upstream \n    dependent demand based on propogate_distribution and propogate_BOM methods\n    It will also maintain a fulfilled column in O_DemandAnalysis table to keep track of which \n    demands are already satisfied''''''\n\n    insert_log(conn, f\"{''-''* 5} Demand Propagation Started {''-''* 5}\")\n    ct = check_for_loops(conn)\n    if ct > 0:\n        insert_log(conn, \"Demand Propogation: Check for loops in validation\")\n\n    conn.execute(\"DELETE FROM O_DemandAnalysis\")\n    populate_periods(conn)\n    query = \"\"\"INSERT INTO O_DemandAnalysis (ItemId, LocationId, FulFilledQuantity, Quantity, Iteration)\n                select df.ItemId, df.LocationId, 0,  Sum(df.Quantity), 1\n                from I_ForecastOrders df,\n                     O_Period dp,\n                     I_InventoryPolicy di\n                WHERE df.ForecastArrivalDate = dp.PeriodStart\n                AND   df.ItemId = di.ItemId\n                AND   df.LocationId = di.LocationId\n                Group BY df.ItemId, df.LocationId\"\"\"\n    conn.execute(query)\n    propogate_distribution(conn)\n    ct = 1\n    while ct > 0:\n        row = conn.execute(bom_select_query).fetchone()\n        if row:\n            propogate_BOM(conn)\n            propogate_distribution(conn)\n        else:\n            ct = 0\n    aggregate_demand_analysis(conn)\n    insert_log(conn, f\"{''-''* 5} Demand Propagation Completed {''-''* 5}\")\n\n\n\ndef propogate_distribution(conn):\n    ''''''This method adds item location demand in O_DemandAnalysis table based on upstream transportation policies''''''\n    ct = 1\n    iteration_count = conn.execute(\"SELECT max(Iteration) from O_DemandAnalysis\").fetchone()[0]\n    if iteration_count is None:\n        iteration_count = 0\n    while ct > 0:\n        conn.execute(\"DROP TABLE IF EXISTS temp.temp_v;\")\n        create_temp_table = \"\"\"CREATE TABLE temp.temp_v\n                                AS\n                                SELECT I_TransportationPolicy.ItemId,\n                                        I_TransportationPolicy.FromLocationId,\n                                        I_TransportationPolicy.toLocationId,\n                                        CAST(1 AS FLOAT)/ct As SplitFactor,\n                                        da.Quantity\n                                    FROM (\n                                            SELECT ItemId,\n                                                    LocationId,\n                                                    Sum(Quantity) AS Quantity\n                                                FROM O_DemandAnalysis\n                                                WHERE O_DemandAnalysis.FulFilledQuantity = 0\n                                                GROUP BY ItemId,\n                                                        LocationId\n                                        )\n                                        da\n                                        LEFT JOIN\n                                        (\n                                            SELECT t1.ItemId,\n                                                   t1.FromLocationId,\n                                                   t1.ToLocationId,\n                                                   t4.ct\n                                                FROM I_TransportationPolicy t1,\n                                                    I_InventoryPolicy t2,\n                                                    I_InventoryPolicy t3,\n                                                    (select ItemId, ToLocationId, COUNT(DISTINCT FromLocationId) AS CT\n                                                    from I_TransportationPolicy\n                                                    GROUP BY ItemId, ToLocationId) t4\n                                                WHERE t1.ItemId = t2.ItemId AND \n                                                    t1.ItemId = t3.ItemId AND \n                                                    t1.ItemId = t4.ItemId AND \n                                                    t1.FromLocationId = t2.LocationId AND \n                                                    t1.ToLocationId = t3.LocationId and\n                                                    t1.ToLocationId = t4.ToLocationId\n                                                GROUP BY t1.ItemId,\n                                                         t1.FromLocationId,\n                                                         t1.ToLocationId\n                                        )\n                                        I_TransportationPolicy ON da.ItemId = I_TransportationPolicy.ItemId AND \n                                                            da.LocationId = I_TransportationPolicy.ToLocationId\n                                    WHERE I_TransportationPolicy.FromLocationId IS NOT NULL\n                                    GROUP BY I_TransportationPolicy.ItemId,\n                                            I_TransportationPolicy.FromLocationId,\n                                            I_TransportationPolicy.toLocationId \"\"\"\n        conn.execute(create_temp_table)\n        iteration_count += 1\n        add_query = \"\"\"UPDATE O_DemandAnalysis\n                    set FulFilledQuantity = 1\n                    FROM temp.temp_v t1\n                    WHERE O_DemandAnalysis.ItemId = t1.ItemId\n                    and   O_DemandAnalysis.LocationId = t1.toLocationId\n                    and   O_DemandAnalysis.FulFilledQuantity = 0;\n                    INSERT INTO O_DemandAnalysis (ItemId, LocationId, FulFilledQuantity,  Quantity, Iteration)\n                    SELECT ItemId, FromLocationId, 0, SUM(SplitFactor * Quantity), ?\n                    FROM temp.temp_v\n                    GROUP BY ItemId, FromLocationId;\"\"\"\n\n        conn.execute(add_query, (iteration_count,))\n        ct = conn.execute(\"select changes()\").fetchone()[0]\n\n\ndef propogate_BOM(conn):\n    ct = 1\n    ''''''This method adds item location demand in O_DemandAnalysis table based on upstream bill of materials''''''\n    iteration_count = conn.execute(\"SELECT max(Iteration) from O_DemandAnalysis\").fetchone()[0]\n    if iteration_count is None:\n        iteration_count = 0\n    while ct > 0:\n        conn.execute(\"DROP TABLE IF EXISTS temp.temp_v;\")\n        create_temp_table = f\"\"\"CREATE TABLE temp.temp_v\n                                as\n                                {bom_select_query}\"\"\"\n        conn.execute(create_temp_table)\n        iteration_count += 1\n        add_query = \"\"\"UPDATE O_DemandAnalysis\n                    set FulFilledQuantity = 1\n                    FROM temp.temp_v t1\n                    WHERE O_DemandAnalysis.ItemId = t1.ToItemId\n                    and   O_DemandAnalysis.LocationId = t1.LocationId\n                    and   O_DemandAnalysis.FulFilledQuantity = 0;\n                    INSERT INTO O_DemandAnalysis (ItemId, LocationId, FulFilledQuantity,  Quantity, Iteration)\n                    SELECT FromItemId, LocationId, 0,  SUM(Quantity), ?\n                    FROM temp.temp_v\n                    GROUP BY FromItemId, LocationId;\"\"\"\n\n        conn.execute(add_query, (iteration_count,))\n        ct = conn.execute(\"select changes()\").fetchone()[0]\n\n\ndef aggregate_demand_analysis(conn):\n    '''''' This method aggregates record in O_DemandAnalysis table, so that there are no duplicates''''''\n\n    conn.execute(\"DROP TABLE IF EXISTS temp.temp_v;\")\n    \n    query = \"\"\"CREATE TABLE temp.temp_v\n                AS\n                select ItemId, LocationId,  sum(quantity) as Quantity, \n                max(FulFilledQuantity) as FulFilledQuantity, Max(Iteration) as Iteration\n                from O_DemandAnalysis\n                group by ItemId, LocationId\n                HAVING sum(quantity) > 0\"\"\"\n    \n    conn.execute(query)\n\n    conn.execute(\"DELETE FROM O_DemandAnalysis;\")\n\n    query = \"\"\"Insert into O_DemandAnalysis(ItemId, LocationId, Quantity, \n                FulFilledQuantity, Iteration)\n                select ItemId, LocationId, Quantity, FulFilledQuantity, Iteration\n                FROM  temp.temp_v\"\"\"\n    conn.execute(query)\n\n\ndef check_for_loops(conn):\n    '''''' Model validation has already been completed before running this method, this method will look\n        for loops and will stop demand propagation if it finds any''''''\n    query = \"\"\"select count(*)\n                from O_ModelValidation\n                WHERE ErrorType  = ''Error''\n                AND   ErrorMsg in (''Please check circular relations in TransportationPolicy'',  \n                    ''Please check circular relations in BOMRecipe'')\"\"\"\n    row = conn.execute(query).fetchone()\n    return row[0]\n','Active');\nINSERT INTO S_ExecutionFiles VALUES(18,'validate_model.py',NULL,'cl_compute/utilityMethods/validate_model.py','from .validation_queries import *\nfrom ..sql_connector import insert_log\nfrom .populate_periods import main as populate_periods\nfrom .backup_and_restore import backup_tables, restore_tables\nfrom .populate_defaults import update_defaults\n\ndef main(conn):\n    insert_log(conn, f\"{''-''* 5} Model Validation Started {''-''* 5}\")\n    conn.execute(\"DELETE FROM O_ModelValidation\")\n    validate_primary_keys(conn)\n    validate_periods(conn)\n    populate_periods(conn)\n    validate_foreign_keys(conn)\n    check_min_max_values(conn)\n    verify_numeric_values(conn)\n    run_validation_queries(conn)\n    detect_transport_loop(conn)\n    detect_bom_loop(conn)\n    string_length_validation(conn)\n    max_decimal_validation(conn)\n    backup_tables(conn)\n    update_defaults(conn)\n    cost_validation(conn)\n    split_ratio_validation(conn)\n    restore_tables(conn)\n    insert_log(conn, f\"{''-''* 5} Model Validation Completed {''-''* 5}\")\n\ndef validate_primary_keys(conn):\n    for table_name in primary_keys:\n        col_names = list(primary_keys[table_name])\n        select_query = f\"\"\"SELECT   ''{table_name}'', \n                                    ''({'',''.join(col_names)})'',\n                                    ''(''||[{\"]||'',''||[\".join(col_names)}]||'')'',\n                                    ''Error'' ,\n                                    ''Multiple primary keys, count: ''||count(*)\n                            FROM [{table_name}]\n                            GROUP BY [{''],[''.join(col_names)}]\n                            HAVING COUNT(*) > 1\"\"\"\n        conn.execute(insert_query + select_query)\n        for col_name in col_names:\n            select_query = f\"\"\"SELECT  ''{table_name}'',\n                                      ''{col_name}'',\n                                    [{col_name}],\n                                    ''Error'',\n                                    ''NULL PK, Check if there are any empty rows for this column''\n                                FROM [{table_name}]\n                                WHERE [{col_name}] IS NULL\n                                LIMIT 1\"\"\"\n            conn.execute(insert_query + select_query)\n    insert_log(conn, \"Primary key verification completed\")\n\n\ndef validate_periods(conn):\n    '''''' All validations w.r.t I_ModelSetup table\n        1. I_ModelSetup should have just 1 record,\n        2. Valid start date,\n        3. Valid number of periods\n        4. valid time frequency''''''\n    query = f\"SELECT date(StartDate), TimeFrequency, NumberOfPeriods FROM I_ModelSetup\"\n    all_rows = conn.execute(query).fetchall()\n    query_tpl = None\n    if len(all_rows) > 1:\n        query_tpl = (''I_ModelSetup'', None, None, \"Error\", f\"Multiple rows are not allowed in I_ModelSetup table\")    \n    elif len(all_rows) == 0:\n        query_tpl = (''I_ModelSetup'', None, None, \"Error\", f\"No data in I_ModelSetup table\")\n\n    value_query = \"Values (?, ?, ?, ?, ?)\"\n    if query_tpl:\n        conn.execute(insert_query + value_query, query_tpl)\n        return\n\n    start_date, time_bucket, period_count = all_rows[0]\n\n    if start_date is None:\n        query_tpl = (''I_ModelSetup'', ''StartDate'', start_date, \"Error\", \"Not a valid date\")\n\n    elif period_count is None:\n        query_tpl = (''I_ModelSetup'', ''NumberOfPeriods'', period_count, \"Error\", \"Please define at least 1 period\")\n    elif not float(period_count).is_integer():\n        query_tpl = (''I_ModelSetup'', ''NumberOfPeriods'', period_count, \"Error\", \"Number of periods should be integer\")\n    elif period_count <= 0 or period_count >= 1000:\n        query_tpl = (''I_ModelSetup'', ''NumberOfPeriods'', period_count, \"Error\", \"Invalid number of periods, period count < 1000\")\n    elif time_bucket not in (''Daily'', ''Weekly'', ''Monthly'', ''Quarterly'', ''Yearly''):\n        query_tpl = (''I_ModelSetup'', ''TimeFrequency'', time_bucket, \"Error\", \"Invalid time Bucket\")\n    \n    if query_tpl:\n        conn.execute(insert_query, query_tpl)\n        return\n\n    validation_query = \"\"\" select ''I_ModelSetup'', ''StartDate'', StartDate, ''Error'', ''Start of Period should start on Monday'' \n                            from I_ModelSetup\n                            where TimeFrequency = ''Weekly''\n                            and   strftime(''%w'', date(StartDate)) != ''1''\n                            UNION\n                            select ''I_ModelSetup'', ''StartDate'', date(StartDate), ''Date Error'', ''Start of Period should start on first day of month'' \n                            from I_ModelSetup\n                            where TimeFrequency = ''Monthly''\n                            and   substr(date(StartDate),9,2) != ''01''\n                            UNION\n                            select ''I_ModelSetup'', ''StartDate'', date(StartDate), ''Error'', ''Start of Period should start on first day of quarter'' \n                            from I_ModelSetup\n                            where TimeFrequency = ''Quarterly''\n                            and substr(date(StartDate),6,5) not in (''01-01'', ''04-01'', ''07-01'', ''10-01'')\n                            UNION\n                            select ''I_ModelSetup'', ''StartDate'', date(StartDate), ''Error'', ''Start of Period should start on first day of year'' \n                            from I_ModelSetup\n                            where TimeFrequency = ''Yearly''\n                            and substr(date(StartDate),6,5) not in (''01-01'')\"\"\"                    \n    conn.execute(insert_query + validation_query)\n    insert_log(conn, \"Period verification completed\")\n\ndef validate_foreign_keys(conn):\n    '''''' 1. Check if corresponding record exist in master table, for e.g.\n            a. Item in I_InventoryPolicy should exists in I_ItemMaster table\n            b. Item, Location in I_Processes table should exists in I_InventoryPolicy table\n        All such relation exists in \"foreign_keys\" data structure ''''''\n    \n    for fk_dict, prim_dict in foreign_keys:\n        fk_table = list(fk_dict.keys())[0]\n        prim_table = list(prim_dict.keys())[0]\n        col_names = fk_dict[fk_table]\n        select_query = f\"\"\"SELECT DISTINCT  ''{fk_table}'', \n                                    ''({'',''.join(col_names)})'',\n                                    ''(''||t1.[{\"]||'',''||t1.[\".join(col_names)}]||'')'',\n                                    ''Error'' ,\n                                    ''FK: Row: (''||t1.[{\"]||'',''||t1.[\".join(col_names)}]||'') not in {prim_table}''\n                            from [{fk_table}] t1\n                            LEFT JOIN [{prim_table}] t2\n                            ON 1 = 1 \"\"\"\n        for i in range(len(fk_dict[fk_table])):\n            select_query += f\" AND t1.[{fk_dict[fk_table][i]}] = t2.[{prim_dict[prim_table][i]}]\"\n        select_query += f\"\"\" WHERE t1.[{fk_dict[fk_table][i]}] is not null\n                            AND  t2.[{prim_dict[prim_table][i]}] is null\"\"\"\n        conn.execute(insert_query + select_query)\n    insert_log(conn, \"Foreign key verification completed\")\n\ndef check_min_max_values(conn):\n    '''''' Based on min_max_constraints  data structure, it validates that all max values should not be \n        less than min values''''''\n    for table_name, min_column, max_column in min_max_constraints:\n        table_columns = list()\n        table_columns.append(max_column)\n        query = f\"\"\" select  DISTINCT \n                                ''{table_name}'', \n                                ''{'',''.join(table_columns)}'', \n                                 [{\"]||'', ''||[\".join(table_columns)}], \n                                ''Error'', \n                                ''Value should be numeric else INF''\n                        from {table_name}\n                        WHERE CASE\n                                WHEN {max_column} is NULL THEN 1\n                                WHEN {max_column} = ''INF'' THEN 1\n                                WHEN {max_column} = CAST({max_column} as INTEGER) THEN 1\n                                WHEN {max_column} = CAST({max_column} as Real) THEN 1\n                                ELSE 0 END = 0\"\"\"\n        conn.execute(insert_query + query)\n\n        table_columns.append(min_column)\n        query = f\"\"\"    select  DISTINCT\n                                ''{table_name}'', \n                                ''{'',''.join(table_columns)}'', \n                                 [{\"]||'', ''||[\".join(table_columns)}], \n                                ''Error'', \n                                ''Max Value should be greater than Min Value''\n                        from {table_name}\n                        where ifnull({max_column}, 0) != ''INF''\n                        AND   CAST(ifnull({max_column},999999999) as Real) < ifnull({min_column},0)\"\"\"\n        conn.execute(insert_query + query)\n\n    for table_name, min_column, max_column in min_max_dates:\n        table_columns = list()\n        table_columns.append(max_column)\n        table_columns.append(min_column)\n\n        query = f\"\"\"    select  DISTINCT\n                                ''{table_name}'', \n                                ''{'',''.join(table_columns)}'', \n                                 [{\"]||'', ''||[\".join(table_columns)}], \n                                ''Error'', \n                                ''Max Value should be greater than Min Value''\n                        from {table_name}\n                        where 1 = 1\n                        AND   ifnull({max_column},''9999-12-31'') < ifnull({min_column}, ''1900-01-01'')\"\"\"\n        conn.execute(insert_query + query)\n    insert_log(conn, \"Min Max check completed\")\n\n\ndef verify_numeric_values(conn):\n    '''''' 1. Based on positive_vals data structure, it validates if there are any 0, null or negative values\n            for such columns\n        2. Based on non_negative_vals data structure, check if there are any negatives for such columns\n        3. Based on max_1_values data structure, check if there are any > 1 values for such columns\n        4. Based on boolean_values data structure, check if there are non booleans for such columns''''''\n    for table_name in positive_vals:\n        for col_name in positive_vals[table_name]:\n            table_columns = list()\n            table_columns.append(col_name)\n            select_query = f\"\"\"select   DISTINCT\n                                        ''{table_name}'', \n                                        ''{'',''.join(table_columns)}'', \n                                        [{\"]||'', ''||[\".join(table_columns)}], \n                                        ''Error'', \n                                        ''{col_name} should not be 0''\n                                from [{table_name}]\n                                WHERE CAST(ifnull([{col_name}],0) AS Real) = 0\n                                UNION\n                                select   DISTINCT\n                                        ''{table_name}'', \n                                        ''{'',''.join(table_columns)}'', \n                                         [{\"]||'', ''||[\".join(table_columns)}], \n                                        ''Error'', \n                                        ''Cannot be negative value''\n                                from [{table_name}]\n                                WHERE CAST(ifnull([{col_name}],0) AS Real) < 0\n                                UNION\n                                select   DISTINCT\n                                        ''{table_name}'', \n                                        ''{'',''.join(table_columns)}'', \n                                         [{\"]||'', ''||[\".join(table_columns)}], \n                                        ''Warning'', \n                                        ''Please check your model, such high values are not advised''\n                                from [{table_name}]\n                                WHERE CAST(ifnull([{col_name}],0) AS Real) > 1000000\"\"\"\n            conn.execute(insert_query + select_query)\n    for table_name in null_or_positive:\n        for col_name in null_or_positive[table_name]:\n            table_columns = list()\n            table_columns.append(col_name)\n            select_query = f\"\"\"select   DISTINCT\n                                        ''{table_name}'', \n                                        ''{'',''.join(table_columns)}'', \n                                        [{\"]||'', ''||[\".join(table_columns)}], \n                                        ''Error'', \n                                        ''{col_name} should be non zero positive''\n                                from [{table_name}]\n                                WHERE CAST(ifnull([{col_name}],1) AS Real) <= 0\"\"\"       \n            conn.execute(insert_query + select_query)  \n\n\n    for table_name in non_negative_vals:\n        for col_name in non_negative_vals[table_name]:\n            table_columns = list()\n            table_columns.append(col_name)\n            select_query = f\"\"\"select   DISTINCT\n                                        ''{table_name}'', \n                                        ''{'',''.join(table_columns)}'', \n                                         [{\"]||'', ''||[\".join(table_columns)}], \n                                        ''Negative Value Error'', \n                                        ''Cannot be  negative value''\n                                from [{table_name}]\n                                WHERE CAST(ifnull([{col_name}],0) AS Real) < 0\"\"\"\n            conn.execute(insert_query + select_query)\n\n            select_query = f\"\"\"select   DISTINCT\n                                        ''{table_name}'', \n                                        ''{'',''.join(table_columns)}'', \n                                         [{\"]||'', ''||[\".join(table_columns)}],  \n                                        ''Warning: Numerical Instability'', \n                                        ''Please check your model, such high values are not advised''\n                                from [{table_name}]\n                                WHERE CAST(ifnull([{col_name}],0) AS Real) > 1000000\"\"\"\n            conn.execute(insert_query + select_query)\n    \n    for table_name in max_1_values:\n        for col_name in max_1_values[table_name]:\n            table_columns = list()\n            table_columns.append(col_name)\n            select_query = f\"\"\"select   DISTINCT\n                                        ''{table_name}'', \n                                        ''{'',''.join(table_columns)}'', \n                                         [{\"]||'', ''||[\".join(table_columns)}], \n                                        ''Error'', \n                                        ''Cannot exceed 1''\n                                from [{table_name}]\n                                WHERE CAST(ifnull([{col_name}],0) AS Real) > 1\"\"\"\n            conn.execute(insert_query + select_query)\n\n    for table_name in boolean_values:\n        for col_name in boolean_values[table_name]:\n            table_columns = list()\n            table_columns.append(col_name)\n            select_query = f\"\"\"select   DISTINCT\n                                        ''{table_name}'', \n                                        ''{'',''.join(table_columns)}'', \n                                         [{\"]||'', ''||[\".join(table_columns)}], \n                                        ''Error'', \n                                        ''Please update 0/1 status''\n                                from [{table_name}]\n                                WHERE [{col_name}] not in (0,1)\"\"\"\n            conn.execute(insert_query + select_query)\n    insert_log(conn, \"Numeric check completed\")\n\n\ndef run_validation_queries(conn):\n    '''''' 1. Check if there is any broken link, or if there is no source for non manufacturing item \n        2. Check if no operation process for IsProduction inventory\n        3. Check if there are mutiple item/locations per process id\n        4. Check if there are both inbound and make policies, or if there is any inventory policy which doesnt have any source or destination\n        5. Check if DOSWindow is multiple of period frequency days or non zero DOSWindow in case SafetySockDOS > 0\n        6. Check if SupplyCapacity is null in I_ResourceMaster table\n        7. Check if a record in I_Processes has IsProduction=0 in I_InventoryPolicy table\n        8. Give warning if there are any inactive items in I_ItemMaster table\n        9. Give warning if sales price is less tha unit cost in I_ItemMaster table\n        ''''''\n    conn.execute(insert_query + no_source_query) #1\n    conn.execute(insert_query + no_process_code) #2\n    conn.execute(insert_query + duplicate_processes) #3\n    conn.execute(insert_query + sourcing_warning) #4\n    conn.execute(insert_query + dos_window_error) #5\n    conn.execute(insert_query + null_supply_capacity_query) #6\n    conn.execute(insert_query + no_manufacturing_warning) #7\n    conn.execute(insert_query + inactive_items) #8\n    conn.execute(insert_query + unit_cost_sales_price_check) #9\n\n    insert_log(conn, \"Validation queries executed\")\n\ndef detect_transport_loop(conn):\n    ''''''Check if there are any loops in I_TransportationPolicy table ''''''\n    select_query = \"select DISTINCT t0.ItemId, t0.FromLocationId, t0.ToLocationId \"\n    from_query = \" from I_TransportationPolicy t0 \"\n    where_query = \" WHERE 1 = 1 \"\n    i = 1\n    ct = 1\n    while ct > 0:\n        select_query += f\" , t{i}.ToLocationId\"\n        from_query += f\" ,I_TransportationPolicy t{i} \"\n        where_query += f\" AND  t{i-1}.ItemId = t{i}.ItemId and  t{i-1}.toLocationId = t{i}.fromLocationId\"\n        full_query = select_query + from_query + where_query\n        row = conn.execute(full_query).fetchone()\n        if row is None:\n            ct = 0\n        else:\n            full_query += f\" AND t0.FromLocationId = t{i}.ToLocationId\"\n            rows = conn.execute(full_query).fetchall()\n            if len(rows) > 0:\n                for row in rows:\n                    insert_tpl = (''I_TransportationPolicy'', ''ItemId, FromLocationId, ToLocationId, ..'',\n                                    str(row), ''Error'', ''Please check circular relations in TransportationPolicy'')\n                    conn.execute(insert_query, insert_tpl)\n                ct = 0\n        i += 1\n    insert_log(conn, \"Transportation loop check completed\")        \n\n\ndef detect_bom_loop(conn):\n    ''''''Check if there are any loops in I_Processes, I_BOMRecipe table ''''''\n    select_query = \"\"\"WITH temp_bom\n                        AS\n                        (\n                            select DISTINCT I_BOMRecipe.ItemId as from_item, I_Processes.ItemId as to_item\n                            from I_Processes,\n                                 I_BOMRecipe \n                            WHERE I_Processes.BOMId = I_BOMRecipe.BOMId\n                        )\n                        SELECT t0.from_item, t0.to_item as to_item_0 \"\"\"\n    from_query = \" FROM temp_bom t0 \"\n    where_query = \" WHERE 1 = 1 \"\n    i = 1\n    ct = 1\n    while ct > 0:\n        select_query += f\" , t{i}.to_item as to_item_{i}\"\n        from_query += f\" ,temp_bom t{i} \"\n        where_query += f\" AND  t{i-1}.to_item = t{i}.from_item\"\n        full_query = select_query + from_query + where_query\n        row = conn.execute(full_query).fetchone()\n        if row is None:\n            ct = 0\n        else:\n            full_query += f\" AND t0.from_item = t{i}.to_item\"\n            rows = conn.execute(full_query).fetchall()\n            if len(rows) > 0:\n                for row in rows:\n                    insert_tpl = (''I_BOMRecipe'', ''FromItemId, ToItemId, ..'',\n                                    str(row), ''Error'', ''Please check circular relations in BOMRecipe'')\n                    conn.execute(insert_query, insert_tpl)\n                ct = 0\n        i += 1        \n    insert_log(conn, \"BOM loop check completed\")\n\n\ndef string_length_validation(conn):\n    '''''' 1. Validate if there are any primary column values of length greater than 255 characters ''''''\n\n    for table_name in primary_keys:\n        column_names = list(primary_keys[table_name])\n\n        for column_name in column_names:\n            select_query = f\"\"\" SELECT DISTINCT ''{table_name}'', \n                                ''{column_name}'', \n                                [{column_name}],\n                                ''Warning'', \n                                ''Column value exceeding maximum length of 255 chars''\n                                FROM [{table_name}]\n                                WHERE length([{column_name}]) > 255\"\"\"\n            conn.execute(insert_query + select_query)\n    insert_log(conn, \"String length validated\")\n\n\ndef max_decimal_validation(conn, round_decimals = 5):\n    '''''' Validate if all numeric fields have less than 5 decimals ''''''\n    get_table_sql = \"\"\"select tbl_name from sqlite_schema\n                        where type = ''table''\n                        and substr(tbl_name, 1,2) = ''I_''\"\"\"\n    table_names = conn.execute(get_table_sql).fetchall()\n\n    for table_name in table_names:\n        get_col_sql = \"select name from pragma_table_info(?) WHERE type = ''NUMERIC''\"\n        col_names = conn.execute(get_col_sql, table_name).fetchall()\n        table_cols = list(primary_keys.get(table_name[0], []))\n        \n        for col_name in col_names:\n            table_columns = list(table_cols)\n            table_columns.append(col_name[0])\n\n            c_name = col_name[0]\n            t_name = table_name[0]\n            select_query = f\"\"\" SELECT DISTINCT ''{t_name}'', \n                                ''{'',''.join(table_columns)}'', \n                                [{\"]||'', ''||[\".join(table_columns)}],\n                                ''Warning'', \n                                ''Column value exceeding max {round_decimals} decimals''\n                                FROM [{t_name}]\n                                WHERE instr(CAST([{c_name}] as STRING), ''.'') > 0\n                                and   length(CAST([{c_name}] as STRING)) - \n                                instr(CAST([{c_name}] as STRING), ''.'') > {round_decimals}\"\"\"\n            conn.execute(insert_query + select_query)\n\n    insert_log(conn, \"Decimals validated\")\n\n\ndef cost_validation(conn):\n    '''''' Check if downstream cost is not lower than upstream cost, check are done on:\n        1. Transportation policy check\n        2. Bill of Materials check\n        ''''''\n    select_query = \"\"\"SELECT DISTINCT ''I_InventoryPolicy'',\n                ''(InputProduct, OutputProduct, InputCost, OutputCost)'',\n                ''(''||I_BOMRecipe.ItemId||'',''||I_Processes.ItemId||'',''||round(rmi.InventoryUnitCost * I_BOMRecipe.UsageQuantity,2)||'',''||round(fgi.InventoryUnitCost,2)||'')'',\n                ''Warning'',\n                ''Upstream cost is lower than downstream in BOM''\n                FROM I_Processes ,\n                     I_InventoryPolicy rmi,\n                     I_InventoryPolicy fgi,\n                     I_BOMRecipe\n                WHERE I_Processes.BOMId = I_BOMRecipe.BOMId\n                AND   I_Processes.LocationId = I_BOMRecipe.LocationId\n                AND   rmi.ItemId = I_BOMRecipe.ItemId\n                AND   rmi.LocationId = I_BOMRecipe.LocationId\n                AND   fgi.ItemId = I_Processes.ItemId\n                AND   fgi.LocationId = I_Processes.LocationId\n                AND   ifnull(fgi.InventoryUnitCost,0) < ifnull(rmi.InventoryUnitCost,0) * I_BOMRecipe.UsageQuantity\"\"\"\n    conn.intermediate_commit()\n    conn.execute(insert_query + select_query)\n\n    select_query = \"\"\"SELECT DISTINCT ''I_InventoryPolicy'',\n                                ''(OutputProduct, InputCost, OutputCost)'',\n                                ''(''||output_item||'',''||round(min_cost,2)||'',''||round(di.InventoryUnitCost,2)||'')'',\n                                ''Warning'',\n                                ''Upstream cost is lower than downstream in BOM aggregated''\n                FROM\n                (\n                SELECT output_item, LocationId, sum(ifnull(InventoryUnitCost,0) * UsageQuantity) as min_cost\n                FROM\n                (\n                    select DISTINCT db.ItemId as input_item, db.LocationId,  dop.ItemId as output_item, db.UsageQuantity, di.InventoryUnitCost\n                    from I_BOMRecipe db,\n                        I_Processes dop,\n                        I_InventoryPolicy di\n                    WHERE db.BOMId = dop.BOMId\n                    AND   db.LocationId = dop.LocationId\n                    AND   db.ItemId = di.ItemId\n                    and   db.LocationId = di.LocationId\n                )\n                GROUP BY output_item, LocationId\n                ) t1,\n                I_InventoryPolicy di\n                WHERE t1.output_item = di.ItemId\n                AND   t1.LocationId = t1.LocationId\n                and   t1.min_cost > di.InventoryUnitCost\"\"\"\n    conn.execute(insert_query + select_query)\n\n    tpt_cost_warning = \"\"\"SELECT DISTINCT ''I_TransportationPolicy'',\n                                        ''(FromLocationId, ToLocationId, ItemCode, FromUnitCost, ToUnitCost)'',\n                                        ''(''||dt.FromLocationId||'',''||dt.ToLocationId||'',''||dt.ItemId||'',''||src.InventoryUnitCost||'',''||dest.InventoryUnitCost||'')'',\n                                        ''Warning'',\n                                        ''Upstream cost is lower than downstream in Distribution''\n                        FROM I_TransportationPolicy dt,\n                            I_InventoryPolicy src,\n                            I_InventoryPolicy dest\n                        WHERE dt.FromLocationId = src.LocationId\n                        and   dt.ItemId = src.ItemId\n                        and   dt.ToLocationId = dest.LocationId\n                        and   dt.ItemId = dest.ItemId\n                        and   src.InventoryUnitCost > dest.InventoryUnitCost\"\"\"\n    conn.execute(insert_query + tpt_cost_warning)\n\n\ndef split_ratio_validation(conn):\n    '''''' Check sum of MinSplitRatio in I_TransportationPolicy table and I_Processes table \n        should not be greater than 1 ''''''\n    select_errors = \"\"\"SELECT ''I_Processes'',\n                        ''(ItemId, LocationId, ProcessId)'', \n                            ''(''||ItemId||'',''||LocationId||'',''||ProcessId||'')'',\n                            ''Error'',\n                            ''Different split ratio across process steps''\n                        FROM I_Processes\n                        WHERE MinSplitRatio is NOT NULL\n                        GROUP BY ItemId,\n                                LocationId,\n                                ProcessId\n                        HAVING Min(ifnull(MinSplitRatio, 0)) != Max(ifnull(MinSplitRatio, 0))\"\"\"\n    conn.execute(insert_query + select_errors)\n\n\n    \n    op_split_error = \"\"\"SELECT ''I_Processes'',\n                                ''(ItemId, LocationId)'',\n                                ''('' || ItemId || '','' || LocationId || '')'',\n                                ''Error'',\n                                ''Sum of MinSplitRatio should be less than 1''\n                            FROM (\n                                    SELECT ItemId,\n                                            LocationId,\n                                            ProcessId,\n                                            Max(MinSplitRatio) AS MinSplitRatio\n                                        FROM I_Processes\n                                        WHERE MinSplitRatio IS NOT NULL\n                                        GROUP BY ItemId,\n                                                LocationId,\n                                                ProcessId\n                                )\n                            GROUP BY ItemId,\n                                    LocationId\n                            HAVING ROUND(SUM(MinSplitRatio),9) > 1\"\"\"\n    \n    create_temp_table = \"\"\"CREATE TABLE TEMP.OP_SPLIT_ERRORS AS\n                            SELECT DISTINCT ItemID, LocationId\n                            FROM (\n                                    SELECT ItemId,\n                                            LocationId,\n                                            ProcessId,\n                                            Max(MinSplitRatio) AS MinSplitRatio\n                                        FROM I_Processes\n                                        WHERE MinSplitRatio IS NOT NULL\n                                        GROUP BY ItemId,\n                                                LocationId,\n                                                ProcessId\n                                )\n                            GROUP BY ItemId,\n                                    LocationId\n                            HAVING ROUND(SUM(MinSplitRatio),9) > 1\"\"\"\n\n    conn.execute(insert_query + op_split_error)\n    conn.execute(create_temp_table)\n    \n    row_check = \"\"\"select 1 from I_ProcessesPerPeriod\n                    where MinSplitRatio is not null\"\"\"\n    rows = conn.execute(row_check).fetchone()\n    if rows:\n        multi_period_query = \"\"\"SELECT ''I_ProcessesPerPeriod'',\n                                ''(ItemId, LocationId, PeriodStart)'', \n                                ''(''||ItemId||'',''||LocationId||'',''||date(PeriodStart + julianday(''1899-12-30''))||'')'',\n                                ''Error'',\n                                ''Sum of MinSplitRatio should not be more than 1''\n                        FROM \n                        (\n                            SELECT I_Processes.ItemId,\n                                I_Processes.LocationId,\n                                I_Processes.ProcessId,\n                                dpx.PeriodStart,\n                                max(ifnull(opp.MinSplitRatio, I_Processes.MinSplitRatio)) as MaxMinSplitRatio,\n                                min(ifnull(opp.MinSplitRatio, I_Processes.MinSplitRatio)) as MinMinSplitRatio\n                            from I_Processes,\n                                O_Period dpx\n                            LEFT JOIN I_ProcessesPerPeriod opp\n                            ON I_Processes.ItemId = opp.ItemId\n                            AND I_Processes.LocationId = opp.LocationId\n                            AND I_Processes.ProcessId = opp.ProcessId\n                            and I_Processes.PRocessStep= opp.ProcessStep\n                            and dpx.PEriodStart = opp.StartDate\n                            LEFT JOIN TEMP.OP_SPLIT_ERRORS tosp\n                            ON I_Processes.ItemId = tosp.ItemId\n                            AND I_Processes.LocationId = tosp.LocationId\n                            WHERE  ifnull(opp.MinSplitRatio, I_Processes.MinSplitRatio) IS NOT NULL\n                            AND    tosp.ItemId is null\n                            GROUP BY  I_Processes.ItemId,\n                                    I_Processes.LocationId,\n                                    I_Processes.ProcessId,\n                                    dpx.PeriodStart\n                        )\n                        GROUP BY ItemId, LocationId, PEriodStart\n                        HAVING round(sum(MaxMinSplitRatio),5) > 1\n                        OR round(sum(MinMinSplitRatio),5) > 1\"\"\"\n        conn.execute(insert_query + multi_period_query)\n\n    tp_split_query = \"\"\"select  ''I_TransportationPolicy'',\n                                    ''(ItemId, ToLocationId)'',\n                                    ''(''||ItemId||'',''||ToLocationId||'')'' , \n                                    ''LTSP Error'',\n                                    ''Sum of MinSplitRatio should be less than 1''\n                            from I_TransportationPolicy\n                            WHERE MinSplitRatio IS NOT NULL\n                            GROUP BY ItemId, ToLocationId\n                            HAVING    ROUND(Sum(MinSplitRatio),9) > 1\"\"\"\n    conn.execute(insert_query + tp_split_query)\n\n    create_temp_table = \"\"\"CREATE TABLE TEMP.TP_SPLIT_ERRORS AS\n                            SELECT ItemID, ToLocationId\n                            From I_TransportationPolicy\n                            WHERE MinSplitRatio IS NOT NULL\n                            GROUP BY ItemId, ToLocationId\n                            HAVING    ROUND(Sum(MinSplitRatio),9) > 1\"\"\"\n\n    conn.execute(create_temp_table)\n\n    row_check = \"\"\"select 1 from I_TransportationPolicyPerPeriod\n                    where MinSplitRatio is not null\"\"\"\n    rows = conn.execute(row_check).fetchone()\n    if rows:\n        tp_split_query = \"\"\"select  ''I_TransportationPolicyPerPeriod'',\n                            ''(ItemId, ToLocationId, PeriodStart)'',\n                            ''(''||dt.ItemId||'',''||dt.ToLocationId||'',''||date(dp.PeriodStart + julianday(''1899-12-30''))||'')'' , \n                            ''Error'',\n                            CASE WHEN ROUND(SUM(ifnull(dtp.MinSplitRatio, 0)),3) <= 1 THEN\n                                ''Split factors information incomplete in I_TransportationPolicyPerPeriod vs. I_TransportationPolicy''\n                                ELSE ''Sum of MinSplitRatio should be less than 1'' END\n                    FROM I_TransportationPolicy dt,\n                        O_Period dp\n                    LEFT JOIN I_TransportationPolicyPerPeriod dtp\n                    ON dt.ItemId = dtp.ItemId\n                    AND dt.FromLocationId = dtp.FromLocationId\n                    AND dt.ToLocationId = dtp.ToLocationId\n                    AND dt.ModeId = dtp.ModeId\n                    AND dp.PeriodStart = dtp.StartDate\n                    LEFT JOIN TEMP.TP_SPLIT_ERRORS ttsp\n                    ON dt.ItemId = ttsp.ItemId\n                    AND dt.ToLocationId = ttsp.ToLocationId\n                    WHERE ifnull(dtp.MinSplitRatio, dt.MinSplitRatio) is not null\n                    and   ttsp.ToLocationId is null\n                    GROUP BY dt.ItemId, dt.ToLocationId, dp.PeriodStart\n                    HAVING    ROUND(SUM(ifnull(dtp.MinSplitRatio, dt.MinSplitRatio)),9) > 1\"\"\"\n        conn.execute(insert_query + tp_split_query)\n\n    zero_production = \"\"\"SELECT ''I_TransportationPolicyPerPeriod'', \n                        ''(ItemId, FromLocationId, ToLocationId, PeriodStart)'',\n                        ''(''||t1.ItemId||'',''||t1.LocationId||'',''||t1.ToLocationId||'',''||date(t1.PeriodStart + julianday(''1899-12-30''))||'')'' , \n                        ''Warning'',\n                        ''0 MaxProduction but non zero MinSplitRatio from this location''\n                    FROM\n                    (\n                    SELECT DISTINCT dt.ItemId,\n                        dt.FromLocationId LocationId,\n                        dt.ToLocationId,\n                        dp.PeriodStart,\n                        ifnull(ifnull(dtp.MinSplitRatio, dt.MinSplitRatio),0) as split_ratio\n                    FROM I_TransportationPolicy dt,\n                        O_Period dp\n                    LEFT JOIN I_TransportationPolicyPerPeriod dtp\n                    ON dt.ItemId = dtp.ItemId\n                    AND dt.FromLocationId = dtp.FromLocationId\n                    AND dt.ToLocationId = dtp.ToLocationId\n                    AND dt.ModeId = dtp.ModeId\n                    AND dp.PeriodStart = dtp.StartDate\n                    WHERE ifnull(ifnull(dtp.MinSplitRatio, dt.MinSplitRatio),0) > 0\n                    ) t1,\n                    (\n                    SELECT DISTINCT di.ItemId,\n                        di.LocationId,\n                        dp.PeriodStart\n                    FROM I_InventoryPolicy di,\n                        O_Period dp\n                    LEFT JOIN I_InventoryPolicyPerPeriod dip\n                    ON di.ItemId = dip.ItemId\n                    AND di.LocationId = dip.LocationId\n                    AND dp.PeriodStart = dip.StartDate\n                    WHERE ifnull(ifnull(dip.MaxProductionQuantity, di.MaxProductionQuantity),''100'')  = ''0''\n                    ) t2\n                    WHERE t1.ItemId = t2.ItemId\n                    and   t1.LocationId = t2.LocationId\n                    and   t1.PeriodStart = t2.PEriodStart\"\"\"\n    conn.execute(insert_query + zero_production)\n\n    insert_log(conn, f\"{''-''* 5} Split ratios validated {''-''* 5}\")','Active');\nINSERT INTO S_ExecutionFiles VALUES(19,'validation_queries.py',NULL,'cl_compute/utilityMethods/validation_queries.py','insert_query = \"INSERT INTO O_ModelValidation (TableName, ColumnName, ColumnValue, ErrorType, ErrorMsg)\"\n\nprimary_keys = {\n                ''I_ItemMaster'': [''ItemId''],\n                ''I_LocationMaster'': [''LocationId''],\n                ''I_ModelSetup'': [''ModelName''],\n                ''I_ForecastOrders'': [''OrderId''],\n                ''I_OpeningStocks'':\t[''StockId''],\n                ''I_InventoryPolicy'': [''ItemId'', ''LocationId''],\n                ''I_InventoryPolicyPerPeriod'': [''ItemId'', ''LocationId'', ''StartDate''],\n                ''I_Processes'':\t[''ProcessId'', ''ProcessStep''],\n                ''I_ProcessesPerPeriod'': [''ProcessId'', ''ProcessStep'', ''StartDate''],\n                ''I_ResourceMaster'':\t[''ResourceId''],\n                ''I_ResourcePerPeriod'':\t[''ResourceId'', ''StartDate''],\n                ''I_BOMRecipe'': [''BomId'', ''ItemId'', ''LocationId''],\n                ''I_TransportationPolicy'': [''ItemId'', ''FromLocationId'', ''ToLocationId'', ''ModeId''],\n                ''I_TransportationPolicyPerPeriod'': [''ItemId'', ''FromLocationId'', ''ToLocationId'', ''ModeId'', ''StartDate''],\n                ''I_ForecastRegistration'': [ ''ForecastItemId'', ''LocationId'', ''ItemId'', ''StartDate''],\n                }\n             \nforeign_keys = [    [{''I_InventoryPolicy'': (''ItemId'',)}, {''I_ItemMaster'': (''ItemId'',)}],\n                    [{''I_InventoryPolicy'': (''LocationId'',)}, {''I_LocationMaster'': (''LocationId'',)}],\n                    [{''I_BOMRecipe'': (''BOMId'', ''LocationId'')}, {''I_Processes'': (''BOMId'', ''LocationId'')}],\n                    [{''I_BOMRecipe'': (''ItemId'', ''LocationId'')}, {''I_InventoryPolicy'': (''ItemId'', ''LocationId'')}],\n                    [{''I_ForecastOrders'': (''ItemId'', ''LocationId'')}, {''I_InventoryPolicy'': (''ItemId'', ''LocationId'')}],\n                    [{''I_ForecastOrders'': (''ForecastArrivalDate'',)}, {''O_Period'': (''PeriodStart'',)}],\n                    [{''I_InventoryPolicyPerPeriod'': (''ItemId'', ''LocationId'')}, {''I_InventoryPolicy'': (''ItemId'', ''LocationId'')}],\n                    [{''I_InventoryPolicyPerPeriod'': (''StartDate'',)}, {''O_Period'': (''PeriodStart'',)}],\n                    [{''I_Processes'': (''ItemId'', ''LocationId'')}, {''I_InventoryPolicy'':(''ItemId'', ''LocationId'')}],\n                    [{''I_Processes'': (''ResourceId'', ''LocationId'')}, {''I_ResourceMaster'': (''ResourceId'', ''LocationId'')}],\n                    [{''I_Processes'': (''BOMId'',)}, {''I_BOMRecipe'': (''BOMId'',)}],\n                    [{''I_ProcessesPerPeriod'': (''ItemId'', ''LocationId'', ''ProcessId'', ''ProcessStep'')}, \n                        {''I_Processes'': (''ItemId'', ''LocationId'', ''ProcessId'', ''ProcessStep'')}],\n                    [{''I_ProcessesPerPeriod'': (''StartDate'',)}, {''O_Period'': (''PeriodStart'',)}],\n                    [{''I_ResourceMaster'': (''ResourceId'', )}, {''I_Processes'': (''ResourceId'', )}],\n                    [{''I_ResourcePerPeriod'': (''ResourceId'', )}, {''I_ResourceMaster'': (''ResourceId'', )}],\n                    [{''I_ResourcePerPeriod'': (''StartDate'',)}, {''O_Period'': (''PeriodStart'',)}],\n                    [{''I_OpeningStocks'': (''ItemId'', ''LocationId'')}, {''I_InventoryPolicy'': (''ItemId'', ''LocationId'')}],\n                    [{''I_OpeningStocks'': (''EntryDate'',)}, {''O_Period'': (''PeriodStart'',)}],\n                    [{''I_TransportationPolicy'': (''ItemId'', ''FromLocationId'')}, {''I_InventoryPolicy'': (''ItemId'', ''LocationId'')}],\n                    [{''I_TransportationPolicy'': (''ItemId'', ''ToLocationId'')}, {''I_InventoryPolicy'': (''ItemId'', ''LocationId'')}],\n                    [{''I_TransportationPolicyPerPeriod'': (''ItemId'', ''FromLocationId'', ''ToLocationId'', ''ModeId'')}, \n                        {''I_TransportationPolicy'': (''ItemId'', ''FromLocationId'', ''ToLocationId'', ''ModeId'')}],\n                    [{''I_TransportationPolicyPerPeriod'': (''StartDate'',)}, {''O_Period'': (''PeriodStart'',)}],\n                    [{''I_ForecastRegistration'': (''ForecastItemId'', ''LocationId'')}, {''I_InventoryPolicy'': (''ItemId'', ''LocationId'')}],\n                    [{''I_ForecastRegistration'': (''ItemId'', ''LocationId'')}, {''I_InventoryPolicy'': (''ItemId'', ''LocationId'')}],\n                    [{''I_ForecastRegistration'': (''StartDate'',)}, {''O_Period'': (''PeriodStart'',)}]]\n\n\nmin_max_constraints = [ (''I_InventoryPolicy'',  ''MinEndingInventory'',   ''MaxEndingInventory''),\n                        (''I_InventoryPolicy'', ''MinProductionQuantity'', ''MaxProductionQuantity''),\n                        (''I_InventoryPolicy'', ''InventoryUnitCost'', ''SalesPrice''),\n                        (''I_InventoryPolicyPerPeriod'',  ''MinEndingInventory'',   ''MaxEndingInventory''),\n                        (''I_InventoryPolicyPerPeriod'', ''MinProductionQuantity'', ''MaxProductionQuantity''),\n                        (''I_Processes'', ''MinSplitRatio'', ''MaxSplitRatio''),\n                        (''I_ProcessesPerPeriod'', ''MinSplitRatio'', ''MaxSplitRatio''),\n                        (''I_ResourceMaster'', ''MinUtilization'', ''MaxUtilization''),\n                        (''I_ResourcePerPeriod'', ''MinUtilization'', ''MaxUtilization''),\n                        (''I_TransportationPolicy'', ''MinQuantity'', ''MaxQuantity''),\n                        (''I_TransportationPolicy'', ''MinSplitRatio'', ''MaxSplitRatio''),\n                        (''I_TransportationPolicyPerPeriod'', ''MinQuantity'', ''MaxQuantity''),\n                        (''I_TransportationPolicyPerPeriod'', ''MinSplitRatio'', ''MaxSplitRatio'')]\n\nmin_max_dates = [(''I_ForecastRegistration'',''StartDate'', ''EndDate''),\n                        (''I_OpeningStocks'', ''EntryDate'', ''ExpiryDate'')]                        \n\npositive_vals =         {    \n                            ''I_BOMRecipe'': [''UsageQuantity''],\n                            ''I_ForecastOrders'': [''Quantity'', ''SalesPrice''],\n                            ''I_InventoryPolicy'': [''InventoryUnitCost''],\n                            ''I_Processes'': [''UnitOperationTime'', ''Yield''],\n                            ''I_ModelSetup'': [''NumberOfPeriods'', ''InterestRate'']\n                        }\n\nnull_or_positive =  {\n                        ''I_ProcessesPerPeriod'': [''UnitOperationTime'', ''Yield'']\n                    }\n\nnon_negative_vals = {   ''I_InventoryPolicy'': [''MinEndingInventory'', ''MaxEndingInventory'', ''MinProductionQuantity'', \n                            ''MaxProductionQuantity'',''InventoryUnitCost'', ''InventoryHoldingCost'', ''SalesPrice'', \n                            ''SafetyStockDOS'', ''DOSWindow'', ''InventoryShelfLife''],\n                        ''I_InventoryPolicyPerPeriod'': [''MinEndingInventory'', ''MaxEndingInventory'', ''MinProductionQuantity'', \n                                                       ''MaxProductionQuantity''],\n                        ''I_ItemMaster'': [''SalesPrice'', ''UnitCost''],\n                        ''I_Processes'': [''UnitOperationCost'', ''MOQ'', ''MinSplitRatio''],\n                        ''I_ProcessesPerPeriod'': [''MinSplitRatio''],\n                        ''I_ResourceMaster'': [''SupplyCapacity'', ''MinUtilization''],\n                        ''I_ResourcePerPeriod'': [''SupplyCapacity'', ''MinUtilization''],\n                        ''I_TransportationPolicy'': [''UnitTransportationCost'', ''TransportationLeadTime'', ''MinQuantity'', \n                                             ''MaxQuantity'',  ''MinSplitRatio'', ''MaxSplitRatio''],\n                        ''I_TransportationPolicyPerPeriod'': [''MinQuantity'', ''MinSplitRatio'']\n                    }\n\nmax_1_values = {    ''I_ModelSetup'': [''InterestRate''],\n                    ''I_Processes'': [''Yield'', ''MinSplitRatio'', ''MaxSplitRatio''],\n                    ''I_ProcessesPerPeriod'': [''Yield'', ''MinSplitRatio'', ''MaxSplitRatio''],\n                    ''I_ResourceMaster'': [''MinUtilization'', ''MaxUtilization''],\n                    ''I_ResourcePerPeriod'': [''MinUtilization'', ''MaxUtilization''],\n                    ''I_TransportationPolicy'': [''MinSplitRatio'', ''MaxSplitRatio''],\n                    ''I_TransportationPolicyPerPeriod'': [''MinSplitRatio'', ''MaxSplitRatio'']\n                }\n\n\nboolean_values = {  \n                    ''I_InventoryPolicy'': [''IsProduction'', ''IsStorage'', ''InventoryStatus''],\n                    ''I_ItemMaster'': [''ItemStatus''],\n                #    ''I_ModelSetup'':[''DOSWindowStartPeriod''],\n                    ''I_ResourceMaster'': [''ResourceStatus'']\n                }\n\n\nno_source_query = \"\"\"WITH T1 AS\n                        (\n                            SELECT DISTINCT dop.BOMId, dop.LocationId, dop.ItemId to_item, db.ItemId from_item\n                            FROM I_Processes dop,\n                                I_BOMRecipe db,\n                                I_InventoryPolicy di\n                            WHERE dop.BOMId = db.BOMId\n                            AND   di.ItemId = db.ItemId\n                            and   di.LocationId = db.LocationId\n                            and   di.IsProduction = 0\n                        )\n                        SELECT  ''I_InventoryPolicy'', \n                                ''(ItemId, LocationId)'',\n                                ''(''||T1.from_item||'',''||T1.LocationId||'')'',\n                                ''Error'',\n                                ''No Transportation/Manufacturing policy to this destination'' \n                        FROM T1\n                        LEFT JOIN I_TransportationPolicy\n                        ON    T1.from_item = I_TransportationPolicy.ItemId\n                        and   T1.LocationId = I_TransportationPolicy.ToLocationId\n                        LEFT JOIN I_TransportationPolicy t2\n                        ON    T1.from_item = t2.ItemId\n                        and   T1.LocationId = t2.FromLocationId\n                        WHERE I_TransportationPolicy.FromLocationId IS NULL\n                        AND   t2.ToLocationId is not NULL\n                        UNION\n                        SELECT  ''I_InventoryPolicy'', \n                                ''(ItemId, LocationId)'',\n                                ''(''||di.ItemId||'',''||di.LocationId||'')'',\n                                ''Error'',\n                                ''No Transportation/Manufacturing policy to this destination''\n                        FROM\n                        (\n                            select t1.ItemId, t1.FromLocationId, t1.ToLocationId\n                            from I_TransportationPolicy t1\n                            LEFT JOIN I_TransportationPolicy t2\n                            ON t1.ItemId = t2.ItemId\n                            and t1.FromLocationId = t2.ToLocationId\n                            WHERE t2.ToLocationId is NULL\n                        ) t3,\n                        I_InventoryPolicy di\n                        WHERE t3.ItemId = di.ItemId\n                        and   t3.FromLocationId = di.LocationId\n                        and   di.IsProduction = 0\n                        UNION\n                        SELECT DISTINCT ''I_ForecastOrders'',\n                                        ''(ItemId, LocationId)'',\n                                        ''('' || df.ItemId || '','' || df.LocationId || '')'',\n                                        ''Error'',\n                                        ''No Transportation/Manufacturing policy for this Forecast Order Item''\n                        FROM (\n                                SELECT DISTINCT ifnull(I_ForecastRegistration.ItemId, I_ForecastOrders.ItemId) AS ItemId,\n                                                I_ForecastOrders.LocationId\n                                FROM I_ForecastOrders\n                                        LEFT JOIN\n                                        I_ForecastRegistration ON I_ForecastOrders.ItemId = I_ForecastRegistration.ForecastItemId AND \n                                                                I_ForecastOrders.LocationId = I_ForecastRegistration.LocationId AND \n                                                                I_ForecastOrders.ForecastArrivalDate >= I_ForecastRegistration.StartDate AND \n                                                                I_ForecastOrders.ForecastArrivalDate <= I_ForecastRegistration.EndDate\n                                WHERE I_ForecastOrders.Quantity > 0\n                        )\n                        df\n                        LEFT JOIN\n                        I_TransportationPolicy dt ON df.ItemId = dt.ItemId AND \n                                                df.LocationId = dt.toLocationId\n                        LEFT JOIN\n                        (\n                                SELECT ItemId, LocationId\n                                FROM I_InventoryPolicy\n                                WHERE IsProduction = 1\n                        )k2 \n                        ON  df.ItemId = k2.ItemId AND \n                            df.LocationId = k2.LocationId\n                        WHERE dt.fromLocationId IS NULL AND \n                        k2.LocationId IS NULL\"\"\"\n\nno_process_code = \"\"\"SELECT  ''I_InventoryPolicy'', \n                                ''(ItemId, LocationId)'',\n                                ''(''||d1.ItemId||'',''||d1.LocationId||'')'',\n                                ''Error'',\n                                ''No Process in I_Processes Table''\n                        from I_InventoryPolicy d1\n                        LEFT JOIN I_Processes d2\n                        ON d1.ItemId = d2.ItemId\n                        and d1.LocationId = d2.LocationId\n                        WHERE d1.IsProduction = 1\n                        and   d2.ProcessId is NULL\"\"\"\n\nduplicate_processes = \"\"\"SELECT  ''I_Processes'', \n                            ''ProcessId'',\n                            ProcessId,\n                            ''Error'',\n                            ''ProcessId associated with multiple Item, Locations''\n                    FROM I_Processes\n                    GROUP BY ProcessId\n                    having count(DISTINCT ItemId||LocationId) > 1\n                    UNION\n                    SELECT  ''I_Processes'', \n                            ''BOMId'',\n                            BOMId,\n                            ''Error'',\n                            ''BOMId associated with multiple Item, Locations''\n                    FROM I_Processes\n                    WHERE BOMId is not null\n                    GROUP BY BOMId\n                    having count(DISTINCT ItemId||LocationId) > 1\n                    UNION\n                    SELECT  ''I_Processes'', \n                            ''ProcessId'',\n                            ProcessId,\n                            ''Error'',\n                            \"ProcessId associated with multiple BOM''s\"\n                    from I_Processes\n                    group by ProcessId\n                    HAVING count(distinct BOMId) > 1\n                    UNION\n                    SELECT  ''I_BOMRecipe'', \n                            ''BOMId'',\n                            BOMId,\n                            ''Error'',\n                            ''BOMId associated with multiple Locations''\n                    from I_BOMRecipe\n                    GROUP BY BOMId\n                    HAVING COUNT(Distinct LocationId)  > 1\"\"\"\n\nsourcing_warning = \"\"\" SELECT  ''I_Processes'', \n                                ''(ItemId, LocationId)'',\n                                ''(''||dop.ItemId||'',''||dop.LocationId||'')'',\n                                ''Warning'',\n                                ''This record has both make and inbound transportation policies''\n                        FROM I_Processes dop\n                        LEFT JOIN I_TransportationPolicy dt\n                        ON dop.ItemId = dt.ItemId\n                        and dop.LocationId = dt.ToLocationId\n                        WHERE dt.FromLocationId is not null\n                        UNION\n                        SELECT  ''I_InventoryPolicy'', \n                                ''(ItemId, LocationId)'',\n                                ''(''||ItemId||'',''||LocationId||'')'',\n                                ''Warning'',\n                                ''This record has no source/destination policies''\n                        FROM\n                        (\n                            SELECT di.ItemId, di.LocationId\n                            FROM I_InventoryPolicy di\n                            LEFT JOIN I_TransportationPolicy dt\n                            ON di.ItemId = dt.ItemId\n                            and di.LocationId = dt.ToLocationId\n                            WHERE dt.FromLocationId is  null\n                            EXCEPT\n                            SELECT dop.ItemId, dop.LocationId\n                            FROM I_Processes dop\n                            EXCEPT\n                            SELECT DISTINCT ForecastItemId, LocationId\n                            FROM I_ForecastRegistration\n                            EXCEPT\n                            select distinct ItemId, LocationId\n                            from I_OpeningStocks\n                            WHERE Quantity > 0\n                        )\"\"\"\n\ndos_window_error = \"\"\" SELECT  ''I_InventoryPolicy'', \n                                ''(ItemId, LocationId)'',\n                                ''(''||ItemId||'',''||LocationId||'')'',\n                                ''DOSWindow Error'',\n                                ''DOSWindow should be multiple of: ''||period_days\n                        FROM\n                        (\n                                SELECT  I_InventoryPolicy.ItemId, \n                                        I_InventoryPolicy.LocationId,\n                                        I_InventoryPolicy.SafetyStockDOS, \n                                        I_InventoryPolicy.DOSWindow, \n                                        I_ModelSetup.TimeFrequency,\n                                        CASE I_ModelSetup.TimeFrequency\n                                        WHEN ''Weekly'' THEN 7\n                                        WHEN ''Monthly'' THEN 30\n                                        WHEN ''Quarterly'' THEN 90\n                                        WHEN ''Yearly'' THEN 365 END AS period_days\n                                from I_InventoryPolicy,\n                                I_ModelSetup\n                                WHERE ifnull(I_InventoryPolicy.SafetyStockDOS,0) > 0\n                                and   ifnull(I_InventoryPolicy.DOSWindow,0) > 0\n                        )\n                        WHERE MOd(DOSWindow, period_days) > 0\n                        UNION\n                        SELECT  ''I_InventoryPolicy'', \n                                ''(ItemId, LocationId)'',\n                                ''(''||ItemId||'',''||LocationId||'')'',\n                                ''DOSWindow Error'',\n                                ''DOSWindow cannot be empty or zero with nonzero safety stock''\n                        FROM I_InventoryPolicy\n                        WHERE ifnull(I_InventoryPolicy.SafetyStockDOS,0) > 0\n                        and   ifnull(I_InventoryPolicy.DOSWindow,0) = 0\n                        UNION\n                        SELECT  ''I_InventoryPolicy'', \n                                ''(ItemId, LocationId)'',\n                                ''(''||ItemId||'',''||LocationId||'')'',\n                                ''MinEndingInventory Error'',\n                                ''MinEndingInventory cannot be non zero for non stocking locations'' \n                        FROM I_InventoryPolicy\n                        WHERE IsStorage = 0\n                        and  IFNULL(MinEndingInventory,0) > 0\n                        UNION\n                        SELECT  ''I_InventoryPolicy'', \n                                ''(ItemId, LocationId)'',\n                                ''(''||ItemId||'',''||LocationId||'')'',\n                                ''MinReleaseTime Error'',\n                                ''MinReleaseTime cannot be non zero for non stocking locations'' \n                        FROM I_InventoryPolicy\n                        WHERE IsStorage = 0\n                        and  IFNULL(MinReleaseTime,0) > 0\n                        UNION\n                        SELECT ''I_InventoryPolicy'', \n                                ''(ItemId, LocationId)'',\n                                ''(''||ItemId||'',''||LocationId||'')'',\n                                ''SafetyStockDOS Error'',\n                                ''SafetyStockDOS cannot be non zero for non stocking locations'' \n                        FROM I_InventoryPolicy\n                        WHERE IsStorage = 0\n                        and IFNULL(SafetyStockDOS,0) > 0\n                        UNION\n                        SELECT ''I_OpeningStocks'', \n                                ''(ItemId, LocationId)'',\n                                ''(''||ds.ItemId||'',''||ds.LocationId||'')'',\n                                ''Stock Error'',\n                                ''Cannot held stock for non stocking locations'' \n                        FROM I_InventoryPolicy di,\n                        I_OpeningStocks ds\n                        WHERE di.ItemId = ds.ItemId\n                        and   di.LocationId = ds.LocationId\n                        and   di.IsStorage = 0\n                        and   ds.Quantity > 0\"\"\"\n\nnull_supply_capacity_query = \"\"\"select ''I_ResourceMaster'', ''ResourceId'', ResourceId, ''Warning'', ''Supply Capacity is empty''\n                                from I_ResourceMaster\n                                where SupplyCapacity is null\"\"\"\n\nno_manufacturing_warning = \"\"\"SELECT  ''I_Processes'', \n                                        ''(ItemId, LocationId)'',\n                                        ''(''||dop.ItemId||'',''||dop.LocationId||'')'',\n                                        ''Warning'',\n                                        ''This record has no make record in I_InventoryPolicy table''\n                                FROM I_Processes dop,\n                                I_InventoryPolicy di\n                                WHERE dop.ItemId = di.ItemId\n                                AND   dop.LocationId = di.LocationId\n                                AND   di.IsProduction = 0\"\"\"\n\ninactive_items = \"\"\"select ''I_ItemMaster'', ''ItemId'', ItemId, ''Warning'', ''Inactive Item''\n                    from I_ItemMaster\n                    WHERE ItemStatus != 1\"\"\"\n\nunit_cost_sales_price_check = \"\"\"select ''I_ItemMaster'', ''ItemId'', ItemId, ''Warning'', ''UnitCost is greater than sales price''\n                                from I_ItemMaster\n                                WHERE UnitCost is not null\n                                AND   SalesPrice is not null\n                                AND   UnitCost > SalesPrice\"\"\"\n\n','Active');\n\n-- Table  S_ModelParams\nDROP TABLE IF EXISTS S_ModelParams;\nCREATE TABLE S_ModelParams (\n    ParamName    VARCHAR,\n    ParamValue   VARCHAR\n);\nINSERT INTO S_ModelParams VALUES('ModelIcon','fas fa-cube');\nINSERT INTO S_ModelParams VALUES('ModelName','Supply Planning DB');\nINSERT INTO S_ModelParams VALUES('DBVersion','1.0.3');\n\n-- Table  S_NotebookContent\nDROP TABLE IF EXISTS S_NotebookContent;\nCREATE TABLE S_NotebookContent (\n    CellId         INTEGER NOT NULL\n                           PRIMARY KEY AUTOINCREMENT,\n    Name           VARCHAR,\n    NotebookId     INTEGER NOT NULL,\n    CellContent    VARCHAR,\n    CellType       VARCHAR,\n    CreationDate   VARCHAR DEFAULT (datetime('now', 'localtime') ),\n    LastUpdateDate VARCHAR DEFAULT (datetime('now', 'localtime') ) \n);\n\n-- Table  S_Notebooks\nDROP TABLE IF EXISTS S_Notebooks;\nCREATE TABLE S_Notebooks (\n    NotebookId     INTEGER NOT NULL\n                           PRIMARY KEY AUTOINCREMENT,\n    Name           VARCHAR,\n    Type           VARCHAR,\n    Status         VARCHAR DEFAULT 'Active',\n    CreationDate   VARCHAR DEFAULT (datetime('now', 'localtime') ),\n    LastUpdateDate VARCHAR DEFAULT (datetime('now', 'localtime') ) \n);\n\n-- Table  S_PackageWheels\nDROP TABLE IF EXISTS S_PackageWheels;\nCREATE TABLE S_PackageWheels (\n\tWheelId\t            INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n\tWheelName\t        VARCHAR UNIQUE,\n    WheelBlob            BLOB NOT NULL,\n\tStatus\t            VARCHAR DEFAULT ('Active')\t\n);\n\n-- Table  S_TableGroup\nDROP TABLE IF EXISTS S_TableGroup;\nCREATE TABLE S_TableGroup (\n    GroupName        VARCHAR,\n    TableName        VARCHAR,\n    TableDisplayName VARCHAR,\n    TableType        VARCHAR,\n    ColumnOrder      VARCHAR,\n    Table_Status     VARCHAR,\n    Freeze_Col_Num   NUMERIC\n);\nINSERT INTO S_TableGroup VALUES('Input Tables','I_ItemMaster','Items','Input',NULL,'Active',NULL);\nINSERT INTO S_TableGroup VALUES('Input Tables','I_LocationMaster','Locations','Input',NULL,'Active',NULL);\nINSERT INTO S_TableGroup VALUES('Input Tables','I_InventoryPolicy','Inventory Policy','Input',NULL,'Active',NULL);\nINSERT INTO S_TableGroup VALUES('Input Tables','I_ModelSetup','Model Setup','Input',NULL,'Active',NULL);\nINSERT INTO S_TableGroup VALUES('Input Tables','I_ForecastOrders','Forecasts','Input',NULL,'Active',NULL);\nINSERT INTO S_TableGroup VALUES('Input Tables','I_Processes','Operation Processes','Input',NULL,'Active',NULL);\nINSERT INTO S_TableGroup VALUES('Input Tables','I_BOMRecipe','Bill Of Materials','Input',NULL,'Active',NULL);\nINSERT INTO S_TableGroup VALUES('Input Tables','I_ResourceMaster','Resource','Input',NULL,'Active',NULL);\nINSERT INTO S_TableGroup VALUES('Input Tables','I_OpeningStocks','Opening Stocks','Input',NULL,'Active',NULL);\nINSERT INTO S_TableGroup VALUES('Input Tables','I_TransportationPolicy','Transportation','Input',NULL,'Active',NULL);\nINSERT INTO S_TableGroup VALUES('Input Tables','I_ForecastRegistration','Registration Calendar','Input',NULL,'Active',NULL);\nINSERT INTO S_TableGroup VALUES('Multiperiod Tables','I_InventoryPolicyPerPeriod','Inv Policy - Period','Input',NULL,'Active',NULL);\nINSERT INTO S_TableGroup VALUES('Multiperiod Tables','I_ProcessesPerPeriod','Operation Processes - Period','Input',NULL,'Active',NULL);\nINSERT INTO S_TableGroup VALUES('Multiperiod Tables','I_TransportationPolicyPerPeriod','Transportation Policy - Period','Input',NULL,'Active',NULL);\nINSERT INTO S_TableGroup VALUES('Multiperiod Tables','I_ResourcePerPeriod','Resource - Period','Input',NULL,'Active',NULL);\nINSERT INTO S_TableGroup VALUES('Output Tables','O_ModelValidation','Validation Output','Output',NULL,'Active',NULL);\nINSERT INTO S_TableGroup VALUES('Output Tables','O_Period','Periods','Output',NULL,'Active',NULL);\nINSERT INTO S_TableGroup VALUES('Output Tables','O_Inventory','Inventory Ouput','Output',NULL,'Active',NULL);\nINSERT INTO S_TableGroup VALUES('Output Tables','O_Transportation','Transportation Output','Output',NULL,'Active',NULL);\nINSERT INTO S_TableGroup VALUES('Output Tables','O_Production','Production Output','Output',NULL,'Active',NULL);\nINSERT INTO S_TableGroup VALUES('Output Tables','O_Objective','Objective Output','Output',NULL,'Active',NULL);\nINSERT INTO S_TableGroup VALUES('Output Tables','O_ForecastRegistration','Forecast Registration','Output',NULL,'Active',NULL);\nINSERT INTO S_TableGroup VALUES('Output Tables','O_DemandAnalysis','Demand Analysis','Output',NULL,'Active',NULL);\nINSERT INTO S_TableGroup VALUES('Log Tables','T_TaskLogs','Task Logs','Task Logs',NULL,'Active',NULL);\nINSERT INTO S_TableGroup VALUES('Log Tables','T_SolverLog','Solver Logs','Solver Logs',NULL,'Active',NULL);\n\n-- Table  S_TableParameters\nDROP TABLE IF EXISTS S_TableParameters;\nCREATE TABLE S_TableParameters (\n    TableName      VARCHAR,\n    ColumnName     VARCHAR,\n    ParameterType  VARCHAR,\n    ParameterValue VARCHAR,\n    UNIQUE(TableName,ColumnName,ParameterType)\n);\nINSERT INTO S_TableParameters VALUES('I_ModelSetup','StartDate','LOV','Date');\nINSERT INTO S_TableParameters VALUES('I_ForecastOrders','ForecastArrivalDate','LOV','Date');\nINSERT INTO S_TableParameters VALUES('I_OpeningStocks','EntryDate','LOV','Date');\nINSERT INTO S_TableParameters VALUES('I_OpeningStocks','ExpiryDate','LOV','Date');\nINSERT INTO S_TableParameters VALUES('I_ForecastRegistration','StartDate','LOV','Date');\nINSERT INTO S_TableParameters VALUES('I_ForecastRegistration','EndDate','LOV','Date');\nINSERT INTO S_TableParameters VALUES('I_InventoryPolicyPerPeriod','StartDate','LOV','Date');\nINSERT INTO S_TableParameters VALUES('I_ProcessesPerPeriod','StartDate','LOV','Date');\nINSERT INTO S_TableParameters VALUES('I_ResourcePerPeriod','StartDate','LOV','Date');\nINSERT INTO S_TableParameters VALUES('I_TransportationPolicyPerPeriod','StartDate','LOV','Date');\n\n-- Table  S_TaskMaster\nDROP TABLE IF EXISTS S_TaskMaster;\nCREATE TABLE S_TaskMaster (\n\tTaskId\t            INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n\tTaskName\t        VARCHAR,\n\tTaskDisplayName\t    VARCHAR,\n    TaskType            VARCHAR,\n\tTaskParameters\t    VARCHAR,\n\tTaskStatus\t        VARCHAR,\n\tTaskLastRunDate\t    VARCHAR,\n\tTaskOutput\t        VARCHAR\n);\nINSERT INTO S_TaskMaster VALUES(1,'validate_model.py','Validate Model','PythonScript',NULL,NULL,NULL,NULL);\nINSERT INTO S_TaskMaster VALUES(2,'clean_model.py','Clean Model','PythonScript',NULL,NULL,NULL,NULL);\nINSERT INTO S_TaskMaster VALUES(3,'optimize.py','Optimize','PythonScript',NULL,NULL,NULL,NULL);\nINSERT INTO S_TaskMaster VALUES(4,'propagate_demand.py','Propagate Demand','PythonScript',NULL,NULL,NULL,NULL);\n\n-- Table  T_QueryLogs\nDROP TABLE IF EXISTS T_QueryLogs;\nCREATE TABLE T_QueryLogs (\n\tLogTime      VARCHAR DEFAULT (datetime('now', 'localtime') ),\n\tQuerySQL     VARCHAR,\n\tQueryMsg     VARCHAR\n);\n\n-- Table  T_SolverLog\nDROP TABLE IF EXISTS T_SolverLog;\nCREATE TABLE T_SolverLog (\n    LogTime    VARCHAR DEFAULT (datetime('now', 'localtime') ),\n    LogMessage VARCHAR\n);\n\n-- Table  T_TaskLogs\nDROP TABLE IF EXISTS T_TaskLogs;\nCREATE TABLE T_TaskLogs (\n        ID              INTEGER PRIMARY KEY AUTOINCREMENT,\n        TaskId          VARCHAR,\n        TaskName        VARCHAR NOT NULL,\n        ProcessId       VARCHAR,\n        TaskStatus      VARCHAR,\n        StartDate       VARCHAR DEFAULT (datetime('now', 'localtime') ),\n        EndDate         VARCHAR,\n        ErrorMsg        VARCHAR,\n        Alerted         INTEGER DEFAULT (0),\n        TaskDbId        VARCHAR,\n        MasterTaskId    VARCHAR\n);\n\n-- Views\nDROP VIEW IF EXISTS V_TEMPV;\nCREATE VIEW V_TEMPV\nAS SELECT 1;\n\n-- For primary key autoincrements the next id to use is stored in\n-- sqlite_sequence\nDELETE FROM main.sqlite_sequence WHERE name='S_ExecutionFiles';\nINSERT INTO main.sqlite_sequence VALUES ('S_ExecutionFiles', 19);\nDELETE FROM main.sqlite_sequence WHERE name='S_TaskMaster';\nINSERT INTO main.sqlite_sequence VALUES ('S_TaskMaster', 4);\n\nCOMMIT TRANSACTION;\n"
}